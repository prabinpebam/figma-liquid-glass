<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Liquid Glass</title>
  <style>
    /* A modern, clean, dark theme */
    :root {
      --bg-color: #1E1E1E;
      --bg-secondary-color: #2A2A2A;
      --text-color: #E0E0E0;
      --text-secondary-color: #9E9E9E;
      --primary-color: #0D99FF;
      --border-color: #3A3A3A;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      margin: 0;
      padding: 16px;
      font-size: 12px;
    }

    h1 {
      color: var(--text-color);
      font-size: 16px;
      font-weight: 600;
      margin: 0 0 16px 0;
      text-align: center;
    }

    #output-area {
      margin-top: 0;
      padding: 0;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary-color);
      text-align: center;
      border-radius: 8px;
      min-height: 150px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    #placeholder {
      color: var(--text-secondary-color);
    }

    #lg-canvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px; /* Match parent */
      object-fit: contain;
    }

    #lg-controls {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .control-row {
      display: grid;
      grid-template-columns: 1fr auto; /* Label | Value */
      grid-template-rows: auto auto; /* Label/Value row | Slider row */
      grid-template-areas: 
        "label value"
        "slider slider";
      align-items: center;
      row-gap: 8px;
      color: var(--text-secondary-color);
    }

    .control-row > span { grid-area: label; }
    .control-row > output { 
      grid-area: value; 
      background-color: var(--bg-secondary-color);
      color: var(--text-color);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      min-width: 24px;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }
    .control-row > input[type="range"] { grid-area: slider; }

    /* Slider Styles */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 20px; /* Increase height to accommodate thumb */
      background: transparent;
      outline: none;
      margin: 0;
    }

    /* Track styles */
    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      background: var(--border-color);
      border-radius: 4px;
    }

    input[type="range"]::-moz-range-track {
      width: 100%;
      height: 4px;
      background: var(--border-color);
      border-radius: 4px;
      border: none;
    }

    /* Thumb styles */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: var(--primary-color);
      cursor: pointer;
      border-radius: 50%;
      border: 2px solid var(--bg-color);
    }

    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: var(--primary-color);
      cursor: pointer;
      border-radius: 50%;
      border: 2px solid var(--bg-color);
      box-sizing: border-box;
    }

    .button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 8px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: background-color 0.2s ease;
    }

    .button:hover {
      background-color: #0B7ACC;
    }
  </style>
</head>
<body>
  <h1>Liquid Glass</h1>

  <div id="output-area">
    <em id="placeholder">Select or create a Liquid Glass element.</em>
    <canvas id="lg-canvas" width="1" height="1" style="display:none"></canvas>
  </div>

  <!-- controls specific to liquid glass -->
  <div id="lg-controls">
    <label class="control-row">
      <span>Edge thickness</span>
      <output id="edge-value">20</output>
      <input type="range" id="edge" min="1" max="50" value="20">
    </label>
    <label class="control-row">
      <span>Refraction strength</span>
      <output id="strength-value">25</output>
      <input type="range" id="strength" min="1" max="100" value="25">
    </label>
    <label class="control-row">
      <span>Chromatic aberration</span>
      <output id="ca-value">5</output>
      <input type="range" id="ca" min="0" max="30" value="5">
    </label>
    <label class="control-row">
      <span>Background blur</span>
      <output id="frost-value">0</output>
      <input type="range" id="frost" min="0" max="20" value="0">
    </label>
  </div>

  <button class="button" id="create-btn" style="width:100%; margin-top: 16px;">Create Liquid Glass</button>

  <!-- inline script (replace old one) -->
  <script>
    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_texCoord;
      void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_position * 0.5 + 0.5;
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;
      varying vec2 v_texCoord;

      uniform vec2 u_resolution;
      uniform sampler2D u_backgroundTexture;
      uniform vec2 u_rectangleSize;
      uniform float u_rectangleCornerRadius;
      uniform float u_edgeDistortionThickness;
      uniform float u_refractionStrength;
      uniform float u_chromaticAberrationAmount;
      uniform float u_frostiness;

      float sdRoundedBox( vec2 p, vec2 b, float r ) {
          vec2 q = abs(p) - b + r;
          return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;
      }

      vec4 renderBackground(vec2 coord) {
          vec2 uv = coord / u_resolution;
          return texture2D(u_backgroundTexture, uv);
      }

      vec4 renderLiquidGlass(vec2 currentPixelCoord, vec2 normDirToCenter, bool caActive, float distortion) {
          // If no blur, do the fast, single-sample version
          if (u_frostiness < 0.1) {
              if (caActive) {
                  float rDist = max(0.0, distortion - u_chromaticAberrationAmount * 0.5);
                  float bDist = distortion + u_chromaticAberrationAmount * 0.5;
                  vec2 rCoord = currentPixelCoord - normDirToCenter * rDist;
                  vec2 gCoord = currentPixelCoord - normDirToCenter * distortion;
                  vec2 bCoord = currentPixelCoord - normDirToCenter * bDist;
                  vec4 color;
                  color.r = renderBackground(rCoord).r;
                  color.g = renderBackground(gCoord).g;
                  color.b = renderBackground(bCoord).b;
                  color.a = renderBackground(gCoord).a;
                  return color;
              } else {
                  vec2 samplingCoord = currentPixelCoord - normDirToCenter * distortion;
                  return renderBackground(samplingCoord);
              }
          }

          // Frosted version: loop over a 5x5 kernel and average the results
          vec4 totalColor = vec4(0.0);
          float sampleCount = 0.0;
          for (int x = -2; x <= 2; x++) {
              for (int y = -2; y <= 2; y++) {
                  vec2 frostOffset = vec2(float(x), float(y)) * u_frostiness * 0.5;
                  vec2 baseFrostedPixelCoord = currentPixelCoord + frostOffset;

                  if (caActive) {
                      float rDist = max(0.0, distortion - u_chromaticAberrationAmount * 0.5);
                      float bDist = distortion + u_chromaticAberrationAmount * 0.5;
                      vec2 rCoord = baseFrostedPixelCoord - normDirToCenter * rDist;
                      vec2 gCoord = baseFrostedPixelCoord - normDirToCenter * distortion;
                      vec2 bCoord = baseFrostedPixelCoord - normDirToCenter * bDist;
                      totalColor.r += renderBackground(rCoord).r;
                      totalColor.g += renderBackground(gCoord).g;
                      totalColor.b += renderBackground(bCoord).b;
                      totalColor.a += renderBackground(gCoord).a;
                  } else {
                      vec2 samplingCoord = baseFrostedPixelCoord - normDirToCenter * distortion;
                      totalColor += renderBackground(samplingCoord);
                  }
                  sampleCount += 1.0;
              }
          }
          return totalColor / sampleCount;
      }

      void main() {
          vec2 glassCenter = u_resolution * 0.5;
          vec2 currentPixelCoord = v_texCoord * u_resolution;
          vec2 relativeToCenter = currentPixelCoord - glassCenter;

          float cornerRadius = min(u_rectangleCornerRadius, min(u_rectangleSize.x, u_rectangleSize.y) * 0.5);
          float sdf = sdRoundedBox(relativeToCenter, u_rectangleSize * 0.5, cornerRadius);

          if (sdf > 0.0) {
              gl_FragColor = renderBackground(currentPixelCoord);
              return;
          }

          bool isInEdge = sdf > -u_edgeDistortionThickness;
          float edgeAmount = isInEdge ? (sdf + u_edgeDistortionThickness) / u_edgeDistortionThickness : 0.0;
          float distortion = isInEdge ? u_refractionStrength * pow(clamp(edgeAmount, 0.0, 1.0), 2.0) : 0.0;
          bool caActive = isInEdge && u_chromaticAberrationAmount > 0.001;
          vec2 normDir = length(relativeToCenter) > 0.001 ? normalize(relativeToCenter) : vec2(0.707, 0.707);

          gl_FragColor = renderLiquidGlass(currentPixelCoord, normDir, caActive, distortion);
      }
    `;

    const OFFSET=20;
    const send=(t,p)=>parent.postMessage({pluginMessage:{type:t,...p}},'*');

    document.getElementById('create-btn').onclick = () => {
      const params = {
        edge: +document.getElementById('edge').value,
        strength: +document.getElementById('strength').value,
        ca: +document.getElementById('ca').value,
        frost: +document.getElementById('frost').value,
      };
      send('create-lg-element', { params });
    };

    /* WebGL init */
    const canvas=document.getElementById('lg-canvas');
    const gl=canvas.getContext('webgl', { preserveDrawingBuffer: true });
    let program, uniforms = {};
    function initGL(){
      const vs=compile(gl,vertexShaderSource,gl.VERTEX_SHADER);
      const fs=compile(gl,fragmentShaderSource,gl.FRAGMENT_SHADER);
      program=link(gl,vs,fs);
      gl.useProgram(program);

      uniforms.edge = gl.getUniformLocation(program,'u_edgeDistortionThickness');
      uniforms.strength = gl.getUniformLocation(program,'u_refractionStrength');
      uniforms.ca = gl.getUniformLocation(program,'u_chromaticAberrationAmount');
      uniforms.frost = gl.getUniformLocation(program, 'u_frostiness');
      uniforms.resolution = gl.getUniformLocation(program,'u_resolution');
      uniforms.rectSize = gl.getUniformLocation(program, 'u_rectangleSize');
      uniforms.cornerRadius = gl.getUniformLocation(program, 'u_rectangleCornerRadius');
      uniforms.backgroundTexture = gl.getUniformLocation(program, 'u_backgroundTexture');

      const pos=gl.getAttribLocation(program,'a_position');
      const quad=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER,quad);
      gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,1]),gl.STATIC_DRAW);
      gl.enableVertexAttribArray(pos);
      gl.vertexAttribPointer(pos,2,gl.FLOAT,false,0,0);
    }
    function compile(gl,src,type){
      const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);
      if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);
      return s;
    }
    function link(gl,vs,fs){
      const p=gl.createProgram();gl.attachShader(p,vs);gl.attachShader(p,fs);
      gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS))throw gl.getProgramInfoLog(p);
      return p;
    }
    initGL();

    /* sliders update their value display and trigger real-time updates */
    const sliders = document.querySelectorAll('input[type="range"]');
    const createBtn = document.getElementById('create-btn');

    function updateValueDisplay(slider) {
      const output = document.getElementById(slider.id + '-value');
      if (output) output.textContent = slider.value;
    }

    function handleSliderChange() {
      if (createBtn.disabled) { // Only send update if an element is selected
        const params = {
          edge: +document.getElementById('edge').value,
          strength: +document.getElementById('strength').value,
          ca: +document.getElementById('ca').value,
          frost: +document.getElementById('frost').value,
        };
        send('update-lg-element', { params });
      }
    }

    sliders.forEach(slider => {
      updateValueDisplay(slider); // Set initial value
      slider.addEventListener('input', () => {
        updateValueDisplay(slider);
        handleSliderChange();
      });
    });

    function updateUniformsAndRedraw(params){
      if (!currentShape) return;
      gl.useProgram(program);
      gl.uniform1f(uniforms.edge, params.edge);
      gl.uniform1f(uniforms.strength, params.strength);
      gl.uniform1f(uniforms.ca, params.ca);
      gl.uniform1f(uniforms.frost, params.frost);
      gl.uniform2f(uniforms.rectSize, currentShape.width, currentShape.height);
      gl.uniform1f(uniforms.cornerRadius, currentShape.cornerRadius);
      redraw();
    }

    /* message handling */
    let tex=null, currentShape = null;
    window.onmessage=e=>{
      const msg=e.data.pluginMessage;
      if (!msg) return;

      if (msg.type === 'update-ui-controls') {
        createBtn.disabled = msg.isSelected;
        document.getElementById('edge').value = msg.params.edge;
        document.getElementById('strength').value = msg.params.strength;
        document.getElementById('ca').value = msg.params.ca;
        document.getElementById('frost').value = msg.params.frost;
        sliders.forEach(updateValueDisplay);
        // Trigger an update to show the preview for the selected item
        if (msg.isSelected) {
          send('update-lg-element', { params: msg.params });
        }
        return;
      }

      if (msg.type === 'selection-cleared') {
        createBtn.disabled = false;
        // Optional: clear canvas or show placeholder
        canvas.style.display = 'none';
        const placeholder = document.getElementById('placeholder');
        if (!placeholder) {
          const newPlaceholder = document.createElement('em');
          newPlaceholder.id = 'placeholder';
          newPlaceholder.textContent = 'Select or create a Liquid Glass element.';
          document.getElementById('output-area').prepend(newPlaceholder);
        }
        return;
      }

      if(msg.type!=='image-captured'||msg.error)return;

      if(msg.shape){
        document.getElementById('placeholder')?.remove();
        currentShape = msg.shape;
        const img=new Image();
        img.onload=()=>{
          canvas.width=img.width; canvas.height=img.height;
          canvas.style.display = 'block';
          gl.viewport(0,0,canvas.width,canvas.height);

          if(!tex) tex=gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D,tex);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);

          gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
          gl.uniform1i(uniforms.backgroundTexture, 0);

          updateUniformsAndRedraw(msg.params);
        };
        img.src=msg.data;
      }
    };

    function redraw(){
      if(!tex || !currentShape)return;
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
      const croppedDataUrl = cropCanvasResult(canvas, OFFSET);
      send('apply-image-fill',{data:croppedDataUrl});
    }

    function cropCanvasResult(sourceCanvas, offset) {
        const tempCanvas = document.createElement('canvas');
        const w = sourceCanvas.width - offset * 2;
        const h = sourceCanvas.height - offset * 2;
        if (w <= 0 || h <= 0) return sourceCanvas.toDataURL('image/png');
        tempCanvas.width = w;
        tempCanvas.height = h;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(sourceCanvas, offset, offset, w, h, 0, 0, w, h);
        return tempCanvas.toDataURL('image/png');
    }
  </script>
 </body>
 </html>