<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Liquid Glass</title>
  <style>
    body {
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }

    h1 {
      color: #333;
    }

    .button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 5px;
    }

    .input {
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 100%;
    }

    #output-area {
      margin-top: 12px;
      padding: 10px;
      border: 2px dashed #007bff;
      background: #fff;
      text-align: center;
    }

    #output-img {
      max-width: 100%;
      display: none;
    }
  </style>
</head>
<body>
  <h1>Liquid Glass</h1>

  <div id="output-area">
    <em id="placeholder">Select a shape to see the effect...</em>
    <canvas id="lg-canvas" width="1" height="1" style="display:none"></canvas>
  </div>

  <!-- controls specific to liquid glass -->
  <div id="lg-controls" style="margin-top:8px">
    <label>Edge thickness <input type="range" id="edge" min="1" max="50" value="20"></label><br>
    <label>Refraction strength <input type="range" id="strength" min="1" max="100" value="25"></label><br>
    <label>Chromatic aberration <input type="range" id="ca" min="0" max="30" value="5"></label><br>
    <label>Background blur <input type="range" id="frost" min="0" max="20" value="0"></label>
  </div>

  <!-- inline script (replace old one) -->
  <script>
    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_texCoord;
      void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_position * 0.5 + 0.5;
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;
      varying vec2 v_texCoord;

      uniform vec2 u_resolution;
      uniform sampler2D u_backgroundTexture;
      uniform vec2 u_rectangleSize;
      uniform float u_rectangleCornerRadius;
      uniform float u_edgeDistortionThickness;
      uniform float u_refractionStrength;
      uniform float u_chromaticAberrationAmount;
      uniform float u_frostiness;

      float sdRoundedBox( vec2 p, vec2 b, float r ) {
          vec2 q = abs(p) - b + r;
          return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;
      }

      vec4 renderBackground(vec2 coord) {
          vec2 uv = coord / u_resolution;
          return texture2D(u_backgroundTexture, uv);
      }

      vec4 renderLiquidGlass(vec2 currentPixelCoord, vec2 normDirToCenter, bool caActive, float distortion) {
          // If no blur, do the fast, single-sample version
          if (u_frostiness < 0.1) {
              if (caActive) {
                  float rDist = max(0.0, distortion - u_chromaticAberrationAmount * 0.5);
                  float bDist = distortion + u_chromaticAberrationAmount * 0.5;
                  vec2 rCoord = currentPixelCoord - normDirToCenter * rDist;
                  vec2 gCoord = currentPixelCoord - normDirToCenter * distortion;
                  vec2 bCoord = currentPixelCoord - normDirToCenter * bDist;
                  vec4 color;
                  color.r = renderBackground(rCoord).r;
                  color.g = renderBackground(gCoord).g;
                  color.b = renderBackground(bCoord).b;
                  color.a = renderBackground(gCoord).a;
                  return color;
              } else {
                  vec2 samplingCoord = currentPixelCoord - normDirToCenter * distortion;
                  return renderBackground(samplingCoord);
              }
          }

          // Frosted version: loop over a 5x5 kernel and average the results
          vec4 totalColor = vec4(0.0);
          float sampleCount = 0.0;
          for (int x = -2; x <= 2; x++) {
              for (int y = -2; y <= 2; y++) {
                  vec2 frostOffset = vec2(float(x), float(y)) * u_frostiness * 0.5;
                  vec2 baseFrostedPixelCoord = currentPixelCoord + frostOffset;

                  if (caActive) {
                      float rDist = max(0.0, distortion - u_chromaticAberrationAmount * 0.5);
                      float bDist = distortion + u_chromaticAberrationAmount * 0.5;
                      vec2 rCoord = baseFrostedPixelCoord - normDirToCenter * rDist;
                      vec2 gCoord = baseFrostedPixelCoord - normDirToCenter * distortion;
                      vec2 bCoord = baseFrostedPixelCoord - normDirToCenter * bDist;
                      totalColor.r += renderBackground(rCoord).r;
                      totalColor.g += renderBackground(gCoord).g;
                      totalColor.b += renderBackground(bCoord).b;
                      totalColor.a += renderBackground(gCoord).a;
                  } else {
                      vec2 samplingCoord = baseFrostedPixelCoord - normDirToCenter * distortion;
                      totalColor += renderBackground(samplingCoord);
                  }
                  sampleCount += 1.0;
              }
          }
          return totalColor / sampleCount;
      }

      void main() {
          vec2 glassCenter = u_resolution * 0.5;
          vec2 currentPixelCoord = v_texCoord * u_resolution;
          vec2 relativeToCenter = currentPixelCoord - glassCenter;

          float cornerRadius = min(u_rectangleCornerRadius, min(u_rectangleSize.x, u_rectangleSize.y) * 0.5);
          float sdf = sdRoundedBox(relativeToCenter, u_rectangleSize * 0.5, cornerRadius);

          if (sdf > 0.0) {
              gl_FragColor = renderBackground(currentPixelCoord);
              return;
          }

          bool isInEdge = sdf > -u_edgeDistortionThickness;
          float edgeAmount = isInEdge ? (sdf + u_edgeDistortionThickness) / u_edgeDistortionThickness : 0.0;
          float distortion = isInEdge ? u_refractionStrength * pow(clamp(edgeAmount, 0.0, 1.0), 2.0) : 0.0;
          bool caActive = isInEdge && u_chromaticAberrationAmount > 0.001;
          vec2 normDir = length(relativeToCenter) > 0.001 ? normalize(relativeToCenter) : vec2(0.707, 0.707);

          gl_FragColor = renderLiquidGlass(currentPixelCoord, normDir, caActive, distortion);
      }
    `;

    const OFFSET=20;
    const send=(t,p)=>parent.postMessage({pluginMessage:{type:t,...p}},'*');

    /* WebGL init */
    const canvas=document.getElementById('lg-canvas');
    const gl=canvas.getContext('webgl', { preserveDrawingBuffer: true });
    let program, uniforms = {};
    function initGL(){
      const vs=compile(gl,vertexShaderSource,gl.VERTEX_SHADER);
      const fs=compile(gl,fragmentShaderSource,gl.FRAGMENT_SHADER);
      program=link(gl,vs,fs);
      gl.useProgram(program);

      uniforms.edge = gl.getUniformLocation(program,'u_edgeDistortionThickness');
      uniforms.strength = gl.getUniformLocation(program,'u_refractionStrength');
      uniforms.ca = gl.getUniformLocation(program,'u_chromaticAberrationAmount');
      uniforms.frost = gl.getUniformLocation(program, 'u_frostiness');
      uniforms.resolution = gl.getUniformLocation(program,'u_resolution');
      uniforms.rectSize = gl.getUniformLocation(program, 'u_rectangleSize');
      uniforms.cornerRadius = gl.getUniformLocation(program, 'u_rectangleCornerRadius');
      uniforms.backgroundTexture = gl.getUniformLocation(program, 'u_backgroundTexture');

      const pos=gl.getAttribLocation(program,'a_position');
      const quad=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER,quad);
      gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,1]),gl.STATIC_DRAW);
      gl.enableVertexAttribArray(pos);
      gl.vertexAttribPointer(pos,2,gl.FLOAT,false,0,0);
    }
    function compile(gl,src,type){
      const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);
      if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);
      return s;
    }
    function link(gl,vs,fs){
      const p=gl.createProgram();gl.attachShader(p,vs);gl.attachShader(p,fs);
      gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS))throw gl.getProgramInfoLog(p);
      return p;
    }
    initGL();

    /* sliders update uniforms */
    const edgeSlider = document.getElementById('edge');
    const strengthSlider = document.getElementById('strength');
    const caSlider = document.getElementById('ca');
    const frostSlider = document.getElementById('frost');
    [edgeSlider, strengthSlider, caSlider, frostSlider].forEach(slider => {
      slider.oninput = updateUniformsAndRedraw;
    });

    function updateUniformsAndRedraw(){
      if (!currentShape) return;
      gl.useProgram(program);
      gl.uniform1f(uniforms.edge, +edgeSlider.value);
      gl.uniform1f(uniforms.strength, +strengthSlider.value);
      gl.uniform1f(uniforms.ca, +caSlider.value);
      gl.uniform1f(uniforms.frost, +frostSlider.value);
      gl.uniform2f(uniforms.rectSize, currentShape.width, currentShape.height);
      gl.uniform1f(uniforms.cornerRadius, currentShape.cornerRadius);
      redraw();
    }

    /* message handling */
    let tex=null, currentShape = null;
    window.onmessage=e=>{
      const msg=e.data.pluginMessage;
      if(!msg||msg.type!=='image-captured'||msg.error)return;

      if(msg.shape){
        document.getElementById('placeholder')?.remove();
        currentShape = msg.shape;
        const img=new Image();
        img.onload=()=>{
          canvas.width=img.width; canvas.height=img.height;
          canvas.style.display = 'block';
          gl.viewport(0,0,canvas.width,canvas.height);

          if(!tex) tex=gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D,tex);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Flip the image to match WebGL's coordinate system
          gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);

          gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
          gl.uniform1i(uniforms.backgroundTexture, 0);

          updateUniformsAndRedraw();
        };
        img.src=msg.data;
      }
    };

    function redraw(){
      if(!tex || !currentShape)return;
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
      const croppedDataUrl = cropCanvasResult(canvas, OFFSET);
      send('apply-image-fill',{data:croppedDataUrl});
    }

    function cropCanvasResult(sourceCanvas, offset) {
        const tempCanvas = document.createElement('canvas');
        const w = sourceCanvas.width - offset * 2;
        const h = sourceCanvas.height - offset * 2;
        if (w <= 0 || h <= 0) return sourceCanvas.toDataURL('image/png');
        tempCanvas.width = w;
        tempCanvas.height = h;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(sourceCanvas, offset, offset, w, h, 0, 0, w, h);
        return tempCanvas.toDataURL('image/png');
    }
  </script>
 </body>
 </html>