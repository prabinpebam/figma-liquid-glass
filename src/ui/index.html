<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Liquid Glass</title>
  <style>
    /* A modern, clean, dark theme */
    :root {
      --bg-color: #1E1E1E;
      --bg-secondary-color: #2A2A2A;
      --text-color: #E0E0E0;
      --text-secondary-color: #9E9E9E;
      --primary-color: #0D99FF;
      --primary-color-hover: #3FB1FF;
      --border-color: #3A3A3A;
      --tab-active-color: #3A3A3A;
    }

    /* Custom Scrollbar Styles */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 3px;
      transition: background-color 0.2s ease;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary-color);
    }

    /* Firefox scrollbar */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) transparent;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      height: 100vh;
      overflow: hidden;
    }

    /* Tab System */
    .tab-container {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-secondary-color);
    }

    .tab-button {
      flex: 1;
      padding: 4px 16px;
      background: transparent;
      border: none;
      color: var(--text-secondary-color);
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .tab-button.active {
      color: var(--text-color);
      background: var(--tab-active-color);
      border-bottom: 2px solid var(--primary-color);
    }

    .tab-button:hover:not(.active) {
      color: var(--text-color);
      background: rgba(255, 255, 255, 0.05);
    }

    /* Main content area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 16px;
      overflow-y: auto;
    }

    #output-area {
      margin: 0 0 16px 0;
      padding: 0;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary-color);
      text-align: center;
      border-radius: 8px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      min-height: 150px;
      max-height: 200px;
      transition: all 0.3s ease;
    }
    
    #output-area.hidden {
      display: none;
    }

    #placeholder {
      color: var(--text-secondary-color);      
    }

    #lg-canvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      object-fit: contain;
    }

    /* Tab Content */
    .tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
    }

    .tab-content.active {
      display: block;
    }

    /* Controls */
    .controls-section {
      margin-bottom: 20px;
    }

    .section-title {
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 4px;
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.5px;
    }

    /* Draggable Input Styles */
    .draggable-input { 
      background-color: var(--bg-secondary-color);
      color: var(--text-color);
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 11px;
      width: 50px;
      max-width: 50px;
      min-width: 32px;
      text-align: center;
      font-variant-numeric: tabular-nums;
      border: 1px solid transparent;
      cursor: ew-resize;
      transition: all 0.2s ease;
      user-select: none;
      box-sizing: border-box;
    }

    .draggable-input:hover {
      border-color: var(--border-color);
      cursor: ew-resize;
    }

    .draggable-input:focus {
      outline: none;
      border-color: var(--primary-color);
      cursor: text;
      user-select: auto;
    }

    .draggable-input.dragging {
      cursor: ew-resize;
      border-color: var(--primary-color);
      user-select: none;
    }

    /* Updated 2-column control layout */
    .control-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 8px;
    }

    .control-cell {
      display: flex;
      justify-content: space-between;
      align-items: center;
      min-height: 24px;
    }

    .control-cell.empty {
      /* Empty cell for spacing */
    }

    .control-cell .control-label {
      font-size: 12px;
      color: var(--text-secondary-color);
      white-space: nowrap;
    }

    .control-cell .draggable-input,
    .control-cell .color-input {
      flex-shrink: 0;
    }

    /* Full width for blend mode */
    .control-full-width {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 12px;
    }

    .control-full-width .control-label {
      font-size: 12px;
      color: var(--text-secondary-color);
    }

    .control-full-width select {
      flex: 1;
      padding: 4px 6px;
      background: var(--bg-secondary-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
    }

    /* Minimal color picker */
    .color-input {
      width: 50px;
      height: 24px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: transparent;
      cursor: pointer;
      padding: 0;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    .color-input::-webkit-color-swatch-wrapper {
      padding: 0;
      border: none;
      border-radius: 3px;
    }

    .color-input::-webkit-color-swatch {
      border: none;
      border-radius: 3px;
    }

    .color-input::-moz-color-swatch {
      border: none;
      border-radius: 3px;
    }

    .color-input:hover {
      border-color: var(--text-secondary-color);
    }

    /* Main content area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 16px;
      overflow-y: auto;
    }

    #output-area {
      margin: 0 0 16px 0;
      padding: 0;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary-color);
      text-align: center;
      border-radius: 8px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      min-height: 150px;
      max-height: 200px;
      transition: all 0.3s ease;
    }
    
    #output-area.hidden {
      display: none;
    }

    #placeholder {
      color: var(--text-secondary-color);      
    }

    #lg-canvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      object-fit: contain;
    }

    /* Tab Content */
    .tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
    }

    .tab-content.active {
      display: block;
    }

    /* Controls */
    .controls-section {
      margin-bottom: 20px;
    }

    .section-title {
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 4px;
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.5px;
    }

    /* Multi-column control layouts */
    .control-row-2 {
      display: grid;
      grid-template-columns: auto 1fr auto 1fr;
      grid-template-areas: "label1 value1 label2 value2";
      align-items: center;
      margin-bottom: 8px;
      color: var(--text-secondary-color);
      gap: 12px;
    }

    .control-row-3 {
      display: grid;
      grid-template-columns: auto auto 1fr auto 1fr;
      grid-template-areas: "label label1 value1 label2 value2";
      align-items: center;
      margin-bottom: 8px;
      color: var(--text-secondary-color);
      gap: 12px;
    }

    .control-row-4 {
      display: grid;
      grid-template-columns: auto 1fr auto 1fr auto 1fr;
      grid-template-areas: "label1 value1 label2 value2 label3 value3";
      align-items: center;
      margin-bottom: 8px;
      color: var(--text-secondary-color);
      gap: 12px;
    }

    .control-row-full {
      display: grid;
      grid-template-columns: auto 1fr;
      grid-template-areas: "label value";
      align-items: center;
      margin-bottom: 8px;
      color: var(--text-secondary-color);
      gap: 12px;
    }

    .control-label {
      font-size: 12px;
      color: var(--text-secondary-color);
      white-space: nowrap;
    }

    .control-row-2 > .control-label:nth-of-type(1) { grid-area: label1; }
    .control-row-2 > .control-label:nth-of-type(3) { grid-area: label2; }
    .control-row-3 > .control-label:nth-of-type(1) { grid-area: label; }
    .control-row-3 > .control-label:nth-of-type(2) { grid-area: label1; }
    .control-row-3 > .control-label:nth-of-type(4) { grid-area: label2; }
    .control-row-4 > .control-label:nth-of-type(1) { grid-area: label1; }
    .control-row-4 > .control-label:nth-of-type(3) { grid-area: label2; }
    .control-row-4 > .control-label:nth-of-type(5) { grid-area: label3; }
    .control-row-full > .control-label { grid-area: label; }

    .control-row-2 > .draggable-input:nth-of-type(2) { grid-area: value1; }
    .control-row-2 > .draggable-input:nth-of-type(4) { grid-area: value2; }
    .control-row-3 > .draggable-input:nth-of-type(3) { grid-area: value1; }
    .control-row-3 > .draggable-input:nth-of-type(5) { grid-area: value2; }
    .control-row-4 > .draggable-input:nth-of-type(2) { grid-area: value1; }
    .control-row-4 > .draggable-input:nth-of-type(4) { grid-area: value2; }
    .control-row-4 > .draggable-input:nth-of-type(6) { grid-area: value3; }
    .control-row-full > .draggable-input { grid-area: value; }

    .control-row-2 > .color-input:nth-of-type(2) { grid-area: value1; }
    .control-row-2 > .color-input:nth-of-type(4) { grid-area: value2; }
    .control-row-full > .color-input { grid-area: value; }

    .control-row-full > select { 
      grid-area: value;
      padding: 4px 6px;
      background: var(--bg-secondary-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
    }

    /* Sticky Footer */
    .sticky-footer {
      flex-shrink: 0;
      padding: 8px 16px;
      border-top: 1px solid var(--border-color);
      background: var(--bg-color);
    }

    .button-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .button {
      flex-grow: 1;
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 8px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: background-color 0.2s ease;
    }

    .button:hover {
      background-color: var(--primary-color-hover);
    }

    .button:disabled {
      background-color: var(--border-color);
      color: var(--text-secondary-color);
      cursor: not-allowed;
    }

    footer {
      text-align: center;
      color: var(--text-secondary-color);
      font-size: 11px;
    }

    footer a {
      color: var(--text-secondary-color);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: color 0.2s ease;
    }

    footer a:hover {
      color: var(--text-color);
    }

    footer svg {
      fill: currentColor;
    }
  </style>
</head>
<body>
  <!-- Tab Navigation -->
  <div class="tab-container">
    <button class="tab-button active" data-tab="refraction">Refraction</button>
    <button class="tab-button" data-tab="effects">Effects</button>
  </div>

  <!-- Main Content Area -->
  <div class="main-content">
    <!-- Output Area - Only shown on Refraction tab -->
    <div id="output-area">
      <em id="placeholder">      
          Select or create a Liquid Glass element.
          <br><br>
          Plugin needs to be kept open to update the effect.      
      </em>
      <canvas id="lg-canvas" width="1" height="1" style="display:none"></canvas>
    </div>

    <!-- Refraction Tab -->
    <div class="tab-content active" id="refraction-tab">
      <div class="controls-section">
        <div class="section-title">Refraction</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Thickness</span>
            <input type="text" class="draggable-input" id="edge" value="20" data-min="1" data-max="50">
          </div>
          <div class="control-cell">
            <span class="control-label">Strength</span>
            <input type="text" class="draggable-input" id="strength" value="25" data-min="1" data-max="100">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Aberration</span>
            <input type="text" class="draggable-input" id="ca" value="5" data-min="0" data-max="30">
          </div>
          <div class="control-cell">
            <span class="control-label">Blur</span>
            <input type="text" class="draggable-input" id="frost" value="0" data-min="0" data-max="20">
          </div>
        </div>
      </div>
    </div>

    <!-- Effects Tab -->
    <div class="tab-content" id="effects-tab">
      <!-- Inner Shadow Section -->
      <div class="controls-section">
        <div class="section-title">Inner shadow</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">X offset</span>
            <input type="text" class="draggable-input" id="inner-shadow-x" value="10" data-min="0" data-max="50">
          </div>
          <div class="control-cell">
            <span class="control-label">Y offset</span>
            <input type="text" class="draggable-input" id="inner-shadow-y" value="10" data-min="0" data-max="50">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Blur</span>
            <input type="text" class="draggable-input" id="inner-shadow-blur" value="10" data-min="0" data-max="50">
          </div>
          <div class="control-cell">
            <span class="control-label">Spread</span>
            <input type="text" class="draggable-input" id="inner-shadow-spread" value="0" data-min="0" data-max="50">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Opacity</span>
            <input type="text" class="draggable-input" id="inner-shadow-opacity" value="40" data-min="0" data-max="100">
          </div>
          <div class="control-cell empty"></div>
        </div>
      </div>

      <!-- Edge Highlight Section -->
      <div class="controls-section">
        <div class="section-title">Edge highlight</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Angle</span>
            <input type="text" class="draggable-input" id="stroke-angle" value="0" data-min="0" data-max="360">
          </div>
          <div class="control-cell">
            <span class="control-label">Thickness</span>
            <input type="text" class="draggable-input" id="stroke-thickness" value="1" data-min="0" data-max="10">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Color</span>
            <input type="color" class="color-input" id="stroke-color" value="#ffffff">
          </div>
          <div class="control-cell">
            <span class="control-label">Opacity</span>
            <input type="text" class="draggable-input" id="stroke-opacity" value="100" data-min="0" data-max="100">
          </div>
        </div>
      </div>

      <!-- Reflection Section -->
      <div class="controls-section">
        <div class="section-title">Reflection</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Thickness</span>
            <input type="text" class="draggable-input" id="highlight-stroke-weight" value="12" data-min="0" data-max="50">
          </div>
          <div class="control-cell">
            <span class="control-label">Blur</span>
            <input type="text" class="draggable-input" id="highlight-blur" value="14" data-min="0" data-max="50">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Color</span>
            <input type="color" class="color-input" id="reflection-color" value="#ffffff">
          </div>
          <div class="control-cell">
            <span class="control-label">Opacity</span>
            <input type="text" class="draggable-input" id="reflection-opacity" value="100" data-min="0" data-max="100">
          </div>
        </div>
      </div>

      <!-- Tint Section -->
      <div class="controls-section">
        <div class="section-title">Tint</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Color</span>
            <input type="color" class="color-input" id="tint-color" value="#ffffff">
          </div>
          <div class="control-cell">
            <span class="control-label">Opacity</span>
            <input type="text" class="draggable-input" id="tint-opacity" value="20" data-min="0" data-max="100">
          </div>
        </div>
        
        <div class="control-full-width">
          <span class="control-label">Blend mode</span>
          <select id="tint-blend-mode">
            <option value="PASS_THROUGH">Pass through</option>
            <option value="NORMAL" selected>Normal</option>
            <option disabled>────────────</option>
            <option value="DARKEN">Darken</option>
            <option value="MULTIPLY">Multiply</option>
            <option value="PLUS_DARKER">Plus darker</option>
            <option value="COLOR_BURN">Color burn</option>
            <option disabled>────────────</option>
            <option value="LIGHTEN">Lighten</option>
            <option value="SCREEN">Screen</option>
            <option value="PLUS_LIGHTER">Plus lighter</option>
            <option value="COLOR_DODGE">Color dodge</option>
            <option disabled>────────────</option>
            <option value="OVERLAY">Overlay</option>
            <option value="SOFT_LIGHT">Soft light</option>
            <option value="HARD_LIGHT">Hard light</option>
            <option disabled>────────────</option>
            <option value="DIFFERENCE">Difference</option>
            <option value="EXCLUSION">Exclusion</option>
            <option disabled>────────────</option>
            <option value="HUE">Hue</option>
            <option value="SATURATION">Saturation</option>
            <option value="COLOR">Color</option>
            <option value="LUMINOSITY">Luminosity</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <!-- Sticky Footer -->
  <div class="sticky-footer">
    <div class="button-row">
      <button class="button" id="create-btn">Create New</button>
      <button class="button" id="update-all-btn">Update all</button>
    </div>

    <footer>
      by Prabin Pebam
      <a href="https://github.com/prabinpebam/figma-liquid-glass" target="_blank">
        <svg width="12" height="12" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8C0 11.54 2.29 14.53 5.47 15.59C5.87 15.66 6.02 15.42 6.02 15.21C6.02 15.02 6.01 14.49 6.01 13.79C3.92 14.25 3.42 12.86 3.42 12.86C3.06 11.93 2.52 11.69 2.52 11.69C1.81 11.2 2.57 11.2 2.57 11.2C3.35 11.25 3.78 12.01 3.78 12.01C4.48 13.24 5.64 12.88 6.08 12.69C6.15 12.22 6.33 11.9 6.53 11.73C4.75 11.53 2.87 10.89 2.87 7.91C2.87 7.02 3.18 6.29 3.64 5.71C3.57 5.51 3.33 4.79 3.71 3.94C3.71 3.94 4.39 3.72 5.99 4.76C6.63 4.58 7.32 4.49 8 4.49C8.68 4.49 9.37 4.58 10.01 4.76C11.61 3.72 12.29 3.94 12.29 3.94C12.67 4.79 12.43 5.51 12.36 5.71C12.82 6.29 13.13 7.02 13.13 7.91C13.13 10.9 11.24 11.53 9.46 11.73C9.71 11.95 9.99 12.38 9.99 13.01C9.99 13.89 9.98 14.97 9.98 15.21C9.98 15.42 10.13 15.67 10.54 15.59C13.71 14.53 16 11.53 16 8C16 3.58 12.42 0 8 0Z"></path></svg>
        figma-liquid-glass
      </a>
    </footer>
  </div>

  <!-- JavaScript -->
  <script>
    console.log('Starting UI initialization...');

    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_texCoord;
      void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_position * 0.5 + 0.5;
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;
      varying vec2 v_texCoord;

      uniform vec2 u_resolution;
      uniform sampler2D u_backgroundTexture;
      uniform sampler2D u_sdfTexture;
      uniform vec2 u_rectangleSize;
      uniform float u_rectangleCornerRadius;
      uniform float u_edgeDistortionThickness;
      uniform float u_refractionStrength;
      uniform float u_chromaticAberrationAmount;
      uniform float u_frostiness;
      uniform int u_shapeType;
      uniform bool u_useSDFTexture;

      float sdRoundedBox( vec2 p, vec2 b, float r ) {
          vec2 q = abs(p) - b + r;
          return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;
      }

      float sdEllipse( vec2 p, vec2 r ) {
          float k0 = length(p/r);
          float k1 = length(p/(r*r));
          return k0*(k0-1.0)/k1;
      }

      vec4 renderBackground(vec2 coord) {
          vec2 uv = coord / u_resolution;
          return texture2D(u_backgroundTexture, uv);
      }

      vec4 renderLiquidGlass(vec2 currentPixelCoord, vec2 normDirToCenter, bool caActive, float distortion) {
          if (u_frostiness < 0.1) {
              if (caActive) {
                  float rDist = max(0.0, distortion - u_chromaticAberrationAmount * 0.5);
                  float bDist = distortion + u_chromaticAberrationAmount * 0.5;
                  vec2 rCoord = currentPixelCoord - normDirToCenter * rDist;
                  vec2 gCoord = currentPixelCoord - normDirToCenter * distortion;
                  vec2 bCoord = currentPixelCoord - normDirToCenter * bDist;
                  vec4 color;
                  color.r = renderBackground(rCoord).r;
                  color.g = renderBackground(gCoord).g;
                  color.b = renderBackground(bCoord).b;
                  color.a = renderBackground(gCoord).a;
                  return color;
              } else {
                  vec2 samplingCoord = currentPixelCoord - normDirToCenter * distortion;
                  return renderBackground(samplingCoord);
              }
          }

          vec4 totalColor = vec4(0.0);
          float sampleCount = 0.0;
          for (int x = -2; x <= 2; x++) {
              for (int y = -2; y <= 2; y++) {
                  vec2 frostOffset = vec2(float(x), float(y)) * u_frostiness * 0.5;
                  vec2 baseFrostedPixelCoord = currentPixelCoord + frostOffset;

                  if (caActive) {
                      float rDist = max(0.0, distortion - u_chromaticAberrationAmount * 0.5);
                      float bDist = distortion + u_chromaticAberrationAmount * 0.5;
                      vec2 rCoord = baseFrostedPixelCoord - normDirToCenter * rDist;
                      vec2 gCoord = baseFrostedPixelCoord - normDirToCenter * distortion;
                      vec2 bCoord = baseFrostedPixelCoord - normDirToCenter * bDist;
                      totalColor.r += renderBackground(rCoord).r;
                      totalColor.g += renderBackground(gCoord).g;
                      totalColor.b += renderBackground(bCoord).b;
                      totalColor.a += renderBackground(gCoord).a;
                  } else {
                      vec2 samplingCoord = baseFrostedPixelCoord - normDirToCenter * distortion;
                      totalColor += renderBackground(samplingCoord);
                  }
                  sampleCount += 1.0;
              }
          }
          return totalColor / sampleCount;
      }

      void main() {
          vec2 glassCenter = u_resolution * 0.5;
          vec2 currentPixelCoord = v_texCoord * u_resolution;
          vec2 relativeToCenter = currentPixelCoord - glassCenter;

          float sdf;
          
          if (u_useSDFTexture) {
              vec2 uv = v_texCoord;
              float dist = texture2D(u_sdfTexture, uv).r;
              sdf = (dist - 0.5) * min(u_resolution.x, u_resolution.y);
          } else if (u_shapeType == 1) {
              sdf = sdEllipse(relativeToCenter, u_rectangleSize * 0.5);
          } else {
              float cornerRadius = min(u_rectangleCornerRadius, min(u_rectangleSize.x, u_rectangleSize.y) * 0.5);
              sdf = sdRoundedBox(relativeToCenter, u_rectangleSize * 0.5, cornerRadius);
          }

          if (sdf > 0.0) {
              gl_FragColor = renderBackground(currentPixelCoord);
              return;
          }

          bool isInEdge = sdf > -u_edgeDistortionThickness;
          float edgeAmount = isInEdge ? (sdf + u_edgeDistortionThickness) / u_edgeDistortionThickness : 0.0;
          float distortion = isInEdge ? u_refractionStrength * pow(clamp(edgeAmount, 0.0, 1.0), 2.0) : 0.0;
          bool caActive = isInEdge && u_chromaticAberrationAmount > 0.001;
          vec2 normDir = length(relativeToCenter) > 0.001 ? normalize(relativeToCenter) : vec2(0.707, 0.707);

          gl_FragColor = renderLiquidGlass(currentPixelCoord, normDir, caActive, distortion);
      }
    `;

    const OFFSET = 20;
    const send = (t, p) => parent.postMessage({ pluginMessage: { type: t, ...p } }, '*');

    // WebGL context and variables
    let canvas, gl, program;
    let uniforms = {};
    let tex = null, sdfTex = null;
    let currentShape = null, currentShapeType = 'rectangle';
    let createBtn, updateAllBtn, placeholder;

    // UI State
    let isMultipleSelection = false;
    let currentBlendModeOriginal = 'NORMAL';

    // Tab system
    function initializeTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');
      const outputArea = document.getElementById('output-area');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');
          
          // Update button states
          tabButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          
          // Update content states
          tabContents.forEach(content => content.classList.remove('active'));
          document.getElementById(targetTab + '-tab').classList.add('active');
          
          // Show/hide output area based on active tab
          if (targetTab === 'refraction') {
            outputArea.classList.remove('hidden');
          } else {
            outputArea.classList.add('hidden');
          }
        });
      });
    }

    function initGL() {
      const vs = compile(gl, vertexShaderSource, gl.VERTEX_SHADER);
      const fs = compile(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
      program = link(gl, vs, fs);
      gl.useProgram(program);

      uniforms.edge = gl.getUniformLocation(program, 'u_edgeDistortionThickness');
      uniforms.strength = gl.getUniformLocation(program, 'u_refractionStrength');
      uniforms.ca = gl.getUniformLocation(program, 'u_chromaticAberrationAmount');
      uniforms.frost = gl.getUniformLocation(program, 'u_frostiness');
      uniforms.resolution = gl.getUniformLocation(program, 'u_resolution');
      uniforms.rectSize = gl.getUniformLocation(program, 'u_rectangleSize');
      uniforms.cornerRadius = gl.getUniformLocation(program, 'u_rectangleCornerRadius');
      uniforms.backgroundTexture = gl.getUniformLocation(program, 'u_backgroundTexture');
      uniforms.sdfTexture = gl.getUniformLocation(program, 'u_sdfTexture');
      uniforms.shapeType = gl.getUniformLocation(program, 'u_shapeType');
      uniforms.useSDFTexture = gl.getUniformLocation(program, 'u_useSDFTexture');

      const pos = gl.getAttribLocation(program, 'a_position');
      const quad = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(pos);
      gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);
    }

    function compile(gl, src, type) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(s) || 'Shader compilation failed');
      }
      return s;
    }

    function link(gl, vs, fs) {
      const p = gl.createProgram();
      gl.attachShader(p, vs);
      gl.attachShader(p, fs);
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(p) || 'Program linking failed');
      }
      return p;
    }

    function updateValueDisplay(slider) {
      const output = document.getElementById(slider.id + '-value');
      if (output) output.textContent = slider.value;
    }

    function getAllParams() {
      return {
        // Refraction params
        edge: +document.getElementById('edge').value,
        strength: +document.getElementById('strength').value,
        ca: +document.getElementById('ca').value,
        frost: +document.getElementById('frost').value,
        
        // Effects params
        innerShadowX: +document.getElementById('inner-shadow-x').value,
        innerShadowY: +document.getElementById('inner-shadow-y').value,
        innerShadowBlur: +document.getElementById('inner-shadow-blur').value,
        innerShadowSpread: +document.getElementById('inner-shadow-spread').value,
        innerShadowOpacity: +document.getElementById('inner-shadow-opacity').value,
        strokeAngle: +document.getElementById('stroke-angle').value,
        strokeColor: document.getElementById('stroke-color').value,
        strokeThickness: +document.getElementById('stroke-thickness').value,
        strokeOpacity: +document.getElementById('stroke-opacity').value,
        highlightStrokeWeight: +document.getElementById('highlight-stroke-weight').value,
        highlightBlur: +document.getElementById('highlight-blur').value,
        reflectionColor: document.getElementById('reflection-color').value,
        reflectionOpacity: +document.getElementById('reflection-opacity').value,
        tintColor: document.getElementById('tint-color').value,
        tintOpacity: +document.getElementById('tint-opacity').value,
        tintBlendMode: document.getElementById('tint-blend-mode').value,
      };
    }

    function updateUniformsAndRedraw(params) {
      if (!currentShape) return;
      gl.useProgram(program);
      gl.uniform1f(uniforms.edge, params.edge);
      gl.uniform1f(uniforms.strength, params.strength);
      gl.uniform1f(uniforms.ca, params.ca);
      gl.uniform1f(uniforms.frost, params.frost);
      gl.uniform2f(uniforms.rectSize, currentShape.width, currentShape.height);
      gl.uniform1f(uniforms.cornerRadius, currentShape.cornerRadius);
      
      const shapeTypeValue = currentShapeType === 'ellipse' ? 1 : 0;
      gl.uniform1i(uniforms.shapeType, shapeTypeValue);
      gl.uniform1i(uniforms.useSDFTexture, currentShapeType === 'complex' ? 1 : 0);
      
      redraw();
    }

    function redraw() {
      if (!tex || !currentShape) return;
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function cropCanvasResult(sourceCanvas, offset) {
      const tempCanvas = document.createElement('canvas');
      const w = sourceCanvas.width - offset * 2;
      const h = sourceCanvas.height - offset * 2;
      if (w <= 0 || h <= 0) return sourceCanvas.toDataURL('image/png');
      tempCanvas.width = w;
      tempCanvas.height = h;
      const ctx = tempCanvas.getContext('2d');
      ctx.drawImage(sourceCanvas, offset, offset, w, h, 0, 0, w, h);
      return tempCanvas.toDataURL('image/png');
    }

    function handleControlChange(parameterName = null) {
      // For single LG element selection - update everything in real-time
      if (createBtn.disabled && !isMultipleSelection) {
        const params = getAllParams();
        send('update-lg-element', { params });
        return;
      }
      
      // For multiple selection - only update effects parameters in real-time
      if (isMultipleSelection && parameterName) {
        const isEffectsParam = !['edge', 'strength', 'ca', 'frost'].includes(parameterName);
        
        if (isEffectsParam) {
          // Send real-time update for effects parameters only
          const singleParam = {};
          singleParam[parameterName] = document.getElementById(getElementIdForParam(parameterName)).value;
          
          // Convert color and numeric values appropriately
          if (parameterName.includes('Color')) {
            singleParam[parameterName] = document.getElementById(getElementIdForParam(parameterName)).value;
          } else if (parameterName === 'tintBlendMode') {
            singleParam[parameterName] = document.getElementById('tint-blend-mode').value;
          } else {
            singleParam[parameterName] = +document.getElementById(getElementIdForParam(parameterName)).value;
          }
          
          send('update-effects-realtime', { 
            parameterName, 
            parameterValue: singleParam[parameterName] 
          });
        }
      }
    }

    function getElementIdForParam(paramName) {
      const paramMap = {
        'innerShadowX': 'inner-shadow-x',
        'innerShadowY': 'inner-shadow-y',
        'innerShadowBlur': 'inner-shadow-blur',
        'innerShadowSpread': 'inner-shadow-spread',
        'innerShadowOpacity': 'inner-shadow-opacity',
        'strokeAngle': 'stroke-angle',
        'strokeColor': 'stroke-color',
        'strokeThickness': 'stroke-thickness',
        'strokeOpacity': 'stroke-opacity',
        'highlightStrokeWeight': 'highlight-stroke-weight',
        'highlightBlur': 'highlight-blur',
        'reflectionColor': 'reflection-color',
        'reflectionOpacity': 'reflection-opacity',
        'tintColor': 'tint-color',
        'tintOpacity': 'tint-opacity',
        'tintBlendMode': 'tint-blend-mode'
      };
      return paramMap[paramName] || paramName;
    }

    // Draggable input functionality
    function setupDraggableInputs() {
      const draggableInputs = document.querySelectorAll('.draggable-input');
      
      draggableInputs.forEach(input => {
        let isDragging = false;
        let startX = 0;
        let startValue = 0;
        let dragSensitivity = 1;
        
        const min = parseFloat(input.dataset.min) || 0;
        const max = parseFloat(input.dataset.max) || 100;
        
        // Get parameter name from input ID
        const parameterName = getParamNameFromElementId(input.id);
        
        // Adjust sensitivity based on range
        const range = max - min;
        if (range <= 50) dragSensitivity = 0.5;
        else if (range <= 100) dragSensitivity = 1;
        else dragSensitivity = 2;

        input.addEventListener('mousedown', (e) => {
          if (e.detail === 1) { // Single click
            setTimeout(() => {
              if (!isDragging) {
                // Focus for editing
                input.focus();
                input.select();
              }
            }, 200);
          }
          
          isDragging = false;
          startX = e.clientX;
          startValue = parseFloat(input.value) || 0;
          
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
          e.preventDefault();
        });

        function onMouseMove(e) {
          const deltaX = e.clientX - startX;
          
          if (Math.abs(deltaX) > 3 && !isDragging) {
            isDragging = true;
            input.classList.add('dragging');
            input.blur(); // Remove focus to prevent text editing
          }
          
          if (isDragging) {
            const newValue = Math.min(max, Math.max(min, startValue + (deltaX * dragSensitivity)));
            const roundedValue = Math.round(newValue * 10) / 10; // Round to 1 decimal
            input.value = roundedValue % 1 === 0 ? roundedValue.toString() : roundedValue.toFixed(1);
            handleControlChange(parameterName);
          }
        }

        function onMouseUp() {
          if (isDragging) {
            input.classList.remove('dragging');
          }
          
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          
          setTimeout(() => {
            isDragging = false;
          }, 100);
        }

        // Handle direct text input
        input.addEventListener('input', () => {
          if (!isDragging) {
            let value = parseFloat(input.value);
            if (isNaN(value)) return;
            
            value = Math.min(max, Math.max(min, value));
            input.value = value % 1 === 0 ? value.toString() : value.toFixed(1);
            handleControlChange(parameterName);
          }
        });

        // Handle Enter key and blur
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            input.blur();
          }
        });

        input.addEventListener('blur', () => {
          let value = parseFloat(input.value);
          if (isNaN(value)) {
            input.value = min.toString();
            value = min;
          }
          
          value = Math.min(max, Math.max(min, value));
          input.value = value % 1 === 0 ? value.toString() : value.toFixed(1);
          handleControlChange(parameterName);
        });
      });
    }

    function getParamNameFromElementId(elementId) {
      const idMap = {
        'edge': 'edge',
        'strength': 'strength', 
        'ca': 'ca',
        'frost': 'frost',
        'inner-shadow-x': 'innerShadowX',
        'inner-shadow-y': 'innerShadowY',
        'inner-shadow-blur': 'innerShadowBlur',
        'inner-shadow-spread': 'innerShadowSpread',
        'inner-shadow-opacity': 'innerShadowOpacity',
        'stroke-angle': 'strokeAngle',
        'stroke-thickness': 'strokeThickness',
        'stroke-opacity': 'strokeOpacity',
        'highlight-stroke-weight': 'highlightStrokeWeight',
        'highlight-blur': 'highlightBlur',
        'reflection-opacity': 'reflectionOpacity',
        'tint-opacity': 'tintOpacity'
      };
      return idMap[elementId] || elementId;
    }

    function initializeUI() {
      console.log('Initializing UI...');
      
      canvas = document.getElementById('lg-canvas');
      if (!canvas) {
        console.error('Canvas element not found');
        return;
      }
      
      gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
      if (!gl) {
        console.error('WebGL not supported');
        return;
      }
      
      createBtn = document.getElementById('create-btn');
      updateAllBtn = document.getElementById('update-all-btn');
      placeholder = document.getElementById('placeholder');
      
      if (!createBtn || !updateAllBtn) {
        console.error('Button elements not found');
        return;
      }
      
      console.log('Elements found, initializing WebGL...');
      
      try {
        initGL();
        console.log('WebGL initialized successfully');
      } catch (e) {
        console.error('WebGL initialization failed:', e);
        return;
      }

      // Initialize tabs
      initializeTabs();

      // Set up draggable inputs
      setupDraggableInputs();

      // Set up event listeners
      createBtn.onclick = () => {
        console.log('Create button clicked');
        const params = getAllParams();
        
        console.log('Button clicked:', createBtn.textContent, params);
        
        if (createBtn.textContent === 'Apply Effect') {
          console.log('Sending apply-effect-to-selection message');
          send('apply-effect-to-selection', { params });
        } else {
          console.log('Sending create-lg-element message');
          send('create-lg-element', { params });
        }
      };

      updateAllBtn.onclick = () => {
        console.log('Update button clicked');
        if (updateAllBtn.textContent === 'Update selection') {
          const params = getAllParams();
          send('update-selection-lg-elements', { params });
        } else {
          send('update-all-lg-elements', {});
        }
      };

      // Set up color pickers with parameter names
      const colorPickers = document.querySelectorAll('input[type="color"]');
      colorPickers.forEach((picker) => {
        const parameterName = getParamNameFromElementId(picker.id);
        picker.addEventListener('input', () => handleControlChange(parameterName));
      });

      // Set up blend mode dropdown
      const blendModeSelect = document.getElementById('tint-blend-mode');
      blendModeSelect.addEventListener('mouseenter', () => {
        currentBlendModeOriginal = blendModeSelect.value;
      });
      
      blendModeSelect.addEventListener('change', () => {
        handleControlChange('tintBlendMode');
      });

      console.log('UI initialized successfully');
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeUI);
    } else {
      initializeUI();
    }

    // Fallback initialization
    setTimeout(() => {
      if (!createBtn) {
        console.log('Fallback initialization attempt');
        initializeUI();
      }
    }, 500);

    // Message handling
    window.onmessage = async (e) => {
      const msg = e.data.pluginMessage;
      if (!msg) return;
      
      console.log('UI received message:', msg.type, msg);

      if (msg.type === 'plugin-ready') {
        console.log('Plugin ready, ensuring UI is initialized');
        if (!createBtn) {
          initializeUI();
        }
        return;
      }

      if (msg.type === 'update-ui-controls') {
        isMultipleSelection = msg.isMultipleSelection || false;
        createBtn.disabled = msg.isSelected;
        createBtn.textContent = 'Create New';
        updateAllBtn.textContent = 'Update selection';
        
        // Update refraction params
        document.getElementById('edge').value = msg.params.edge || 20;
        document.getElementById('strength').value = msg.params.strength || 25;
        document.getElementById('ca').value = msg.params.ca || 5;
        document.getElementById('frost').value = msg.params.frost || 0;
        
        // Update effects params
        if (msg.effectsParams) {
          const ep = msg.effectsParams;
          document.getElementById('inner-shadow-x').value = ep.innerShadowX || 10;
          document.getElementById('inner-shadow-y').value = ep.innerShadowY || 10;
          document.getElementById('inner-shadow-blur').value = ep.innerShadowBlur || 10;
          document.getElementById('inner-shadow-spread').value = ep.innerShadowSpread || 0;
          document.getElementById('inner-shadow-opacity').value = ep.innerShadowOpacity || 40;
          document.getElementById('stroke-angle').value = ep.strokeAngle || 0;
          document.getElementById('stroke-color').value = ep.strokeColor || '#ffffff';
          document.getElementById('stroke-opacity').value = ep.strokeOpacity || 100;
          document.getElementById('highlight-stroke-weight').value = ep.highlightStrokeWeight || 12;
          document.getElementById('highlight-blur').value = ep.highlightBlur || 14;
          document.getElementById('reflection-color').value = ep.reflectionColor || '#ffffff';
          document.getElementById('reflection-opacity').value = ep.reflectionOpacity || 100;
          document.getElementById('tint-color').value = ep.tintColor || '#ffffff';
          document.getElementById('tint-opacity').value = ep.tintOpacity || 20;
          document.getElementById('tint-blend-mode').value = ep.tintBlendMode || 'NORMAL';
        }

        // Show "Multiple values" indicators if needed
        if (isMultipleSelection) {
          document.querySelectorAll('.label').forEach(label => {
            if (!label.querySelector('.multiple-values')) {
              const span = document.createElement('span');
              span.className = 'multiple-values';
              span.textContent = 'Multiple values';
              label.appendChild(span);
            }
          });
        } else {
          document.querySelectorAll('.multiple-values').forEach(span => span.remove());
        }
        
        if (msg.isSelected && !isMultipleSelection) {
          send('update-lg-element', { params: getAllParams() });
        }
        return;
      }

      if (msg.type === 'selection-changed') {
        isMultipleSelection = msg.isMultipleSelection || false;
        
        if (msg.canApplyEffect) {
          createBtn.textContent = 'Apply Effect';
          createBtn.disabled = false;
          updateAllBtn.textContent = 'Update selection';
        } else if (msg.isLgElement) {
          createBtn.textContent = 'Create New';
          createBtn.disabled = true;
          updateAllBtn.textContent = 'Update selection';
        } else {
          createBtn.textContent = 'Create New';
          createBtn.disabled = false;
          updateAllBtn.textContent = 'Update selection';
        }
        return;
      }

      if (msg.type === 'selection-cleared') {
        isMultipleSelection = false;
        createBtn.disabled = false;
        createBtn.textContent = 'Create New';
        updateAllBtn.textContent = 'Update all';
        canvas.style.display = 'none';
        
        // Remove multiple values indicators
        document.querySelectorAll('.multiple-values').forEach(span => span.remove());
        
        if (!document.getElementById('placeholder')) {
          const newPlaceholder = document.createElement('em');
          newPlaceholder.id = 'placeholder';
          newPlaceholder.innerHTML = `      
            Select or create a Liquid Glass element.
            <br><br>
            Plugin needs to be kept open to update the effect.      
          `;
          document.getElementById('output-area').prepend(newPlaceholder);
        }
        return;
      }

      if (msg.type !== 'image-captured' || msg.error) return;

      if (msg.shape) {
        document.getElementById('placeholder')?.remove();
        currentShape = msg.shape;
        currentShapeType = msg.shapeType === 'complex' ? 'rectangle' : msg.shapeType;
        
        const img = new Image();
        img.onload = async () => {
          canvas.width = img.width;
          canvas.height = img.height;
          canvas.style.display = 'block';
          gl.viewport(0, 0, canvas.width, canvas.height);

          if (!tex) tex = gl.createTexture();
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, tex);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

          gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
          gl.uniform1i(uniforms.backgroundTexture, 0);

          updateUniformsAndRedraw(msg.params);
          
          const croppedDataUrl = cropCanvasResult(canvas, OFFSET);
          send('apply-image-fill', { data: croppedDataUrl, nodeId: msg.nodeId });
        };
        img.src = msg.data;
      }
    };
  </script>
</body>
</html>