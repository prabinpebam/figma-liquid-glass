<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Liquid Glass</title>
  <style>
    body {
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }

    h1 {
      color: #333;
    }

    .button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 5px;
    }

    .input {
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 100%;
    }

    #output-area {
      margin-top: 12px;
      padding: 10px;
      border: 2px dashed #007bff;
      background: #fff;
      text-align: center;
    }

    #output-img {
      max-width: 100%;
      display: none;
    }
  </style>
</head>
<body>
  <h1>Liquid Glass</h1>

  <!-- effect selector -->
  <fieldset>
    <legend>Effect</legend>
    <label><input type="radio" name="fx" value="none"   /> None</label><br>
    <label><input type="radio" name="fx" value="liquid" /> Liquid glass</label><br>
    <label><input type="radio" name="fx" value="invert" checked/> Invert</label>
  </fieldset>

  <!-- mode selector -->
  <fieldset>
    <legend>Mode</legend>
    <label><input type="radio" name="mode" value="performance" checked/> Performance</label><br>
    <label><input type="radio" name="mode" value="intuitive" /> Intuitive</label>
  </fieldset>

  <button class="button" id="capture-btn">Capture image</button>

  <div id="output-area">
    <em id="placeholder">Captured image will appear here…</em>
    <canvas id="lg-canvas" width="1" height="1" style="display:none"></canvas>
    <img    id="output-img" />
  </div>

  <!-- controls specific to liquid glass -->
  <div id="lg-controls" style="display:none;margin-top:8px">
    <label>Edge thickness <input type="range" id="edge" min="1" max="50" value="20"></label><br>
    <label>Refraction strength <input type="range" id="strength" min="1" max="100" value="25"></label><br>
    <label>Chromatic aberration <input type="range" id="ca" min="0" max="30" value="5"></label>
  </div>

  <!-- inline script (replace old one) -->
  <script>
    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_texCoord;
      void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_position * 0.5 + 0.5;
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;
      varying vec2 v_texCoord;

      uniform vec2 u_resolution;
      uniform sampler2D u_backgroundTexture;
      uniform vec2 u_rectangleSize;
      uniform float u_rectangleCornerRadius;
      uniform float u_edgeDistortionThickness;
      uniform float u_refractionStrength;
      uniform float u_chromaticAberrationAmount;

      float sdRoundedBox( vec2 p, vec2 b, float r ) {
          vec2 q = abs(p) - b + r;
          return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;
      }

      vec4 renderBackground(vec2 coord) {
          vec2 uv = coord / u_resolution;
          return texture2D(u_backgroundTexture, uv);
      }

      vec4 renderLiquidGlass(vec2 currentPixelCoord, vec2 normDirToCenter, bool caActive, float distortion) {
          vec4 refractedBackground;
          if (caActive) {
              float rDist = max(0.0, distortion - u_chromaticAberrationAmount * 0.5);
              float bDist = distortion + u_chromaticAberrationAmount * 0.5;
              vec2 rCoord = currentPixelCoord - normDirToCenter * rDist;
              vec2 gCoord = currentPixelCoord - normDirToCenter * distortion;
              vec2 bCoord = currentPixelCoord - normDirToCenter * bDist;
              refractedBackground.r = renderBackground(rCoord).r;
              refractedBackground.g = renderBackground(gCoord).g;
              refractedBackground.b = renderBackground(bCoord).b;
              refractedBackground.a = renderBackground(gCoord).a;
          } else {
              vec2 samplingCoord = currentPixelCoord - normDirToCenter * distortion;
              refractedBackground = renderBackground(samplingCoord);
          }
          return refractedBackground;
      }

      void main() {
          vec2 glassCenter = u_resolution * 0.5;
          vec2 currentPixelCoord = v_texCoord * u_resolution;
          vec2 relativeToCenter = currentPixelCoord - glassCenter;

          float cornerRadius = min(u_rectangleCornerRadius, min(u_rectangleSize.x, u_rectangleSize.y) * 0.5);
          float sdf = sdRoundedBox(relativeToCenter, u_rectangleSize * 0.5, cornerRadius);

          if (sdf > 0.0) {
              gl_FragColor = renderBackground(currentPixelCoord);
              return;
          }

          bool isInEdge = sdf > -u_edgeDistortionThickness;
          float edgeAmount = isInEdge ? (sdf + u_edgeDistortionThickness) / u_edgeDistortionThickness : 0.0;
          float distortion = isInEdge ? u_refractionStrength * pow(clamp(edgeAmount, 0.0, 1.0), 2.0) : 0.0;
          bool caActive = isInEdge && u_chromaticAberrationAmount > 0.001;
          vec2 normDir = length(relativeToCenter) > 0.001 ? normalize(relativeToCenter) : vec2(0.707, 0.707);

          gl_FragColor = renderLiquidGlass(currentPixelCoord, normDir, caActive, distortion);
      }
    `;

    const OFFSET=20;
    const send=(t,p)=>parent.postMessage({pluginMessage:{type:t,...p}},'*');

    /* radio – effect + mode */
    document.querySelectorAll('input[name="fx"]').forEach(i=>{
      i.addEventListener('change',()=>{ if(i.checked){
        const isLiquid = i.value === 'liquid';
        document.getElementById('lg-controls').style.display = isLiquid ? 'block' : 'none';
        document.getElementById('output-img').style.display = i.value === 'invert' ? 'block' : 'none';
        document.getElementById('lg-canvas').style.display = isLiquid ? 'block' : 'none';
        send('effect-change',{effect:i.value});
      }});
    });
    document.querySelectorAll('input[name="mode"]').forEach(i=>{
      i.addEventListener('change',()=>i.checked&&send('mode-change',{mode:i.value}));
    });

    document.getElementById('capture-btn').onclick=()=>send('capture-image');

    /* WebGL init */
    const canvas=document.getElementById('lg-canvas');
    const gl=canvas.getContext('webgl', { preserveDrawingBuffer: true });
    let program, uniforms = {};
    function initGL(){
      const vs=compile(gl,vertexShaderSource,gl.VERTEX_SHADER);
      const fs=compile(gl,fragmentShaderSource,gl.FRAGMENT_SHADER);
      program=link(gl,vs,fs);
      gl.useProgram(program);

      uniforms.edge = gl.getUniformLocation(program,'u_edgeDistortionThickness');
      uniforms.strength = gl.getUniformLocation(program,'u_refractionStrength');
      uniforms.ca = gl.getUniformLocation(program,'u_chromaticAberrationAmount');
      uniforms.resolution = gl.getUniformLocation(program,'u_resolution');
      uniforms.rectSize = gl.getUniformLocation(program, 'u_rectangleSize');
      uniforms.cornerRadius = gl.getUniformLocation(program, 'u_rectangleCornerRadius');
      uniforms.backgroundTexture = gl.getUniformLocation(program, 'u_backgroundTexture');

      const pos=gl.getAttribLocation(program,'a_position');
      const quad=gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER,quad);
      gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,1]),gl.STATIC_DRAW);
      gl.enableVertexAttribArray(pos);
      gl.vertexAttribPointer(pos,2,gl.FLOAT,false,0,0);
    }
    function compile(gl,src,type){
      const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);
      if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);
      return s;
    }
    function link(gl,vs,fs){
      const p=gl.createProgram();gl.attachShader(p,vs);gl.attachShader(p,fs);
      gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS))throw gl.getProgramInfoLog(p);
      return p;
    }
    initGL();

    /* sliders update uniforms */
    const edgeSlider = document.getElementById('edge');
    const strengthSlider = document.getElementById('strength');
    const caSlider = document.getElementById('ca');
    [edgeSlider, strengthSlider, caSlider].forEach(slider => {
      slider.oninput = updateUniformsAndRedraw;
    });

    function updateUniformsAndRedraw(){
      if (!currentShape) return;
      gl.useProgram(program);
      gl.uniform1f(uniforms.edge, +edgeSlider.value);
      gl.uniform1f(uniforms.strength, +strengthSlider.value);
      gl.uniform1f(uniforms.ca, +caSlider.value);
      gl.uniform2f(uniforms.rectSize, currentShape.width, currentShape.height);
      gl.uniform1f(uniforms.cornerRadius, currentShape.cornerRadius);
      redraw();
    }

    /* message handling */
    let tex=null, currentShape = null;
    window.onmessage=e=>{
      const msg=e.data.pluginMessage;
      if(!msg||msg.type!=='image-captured'||msg.error)return;

      const effect=document.querySelector('input[name="fx"]:checked')?.value;
      if(effect==='invert'){
          cropAndInvert(msg.data).then(url=>{
            const img=document.getElementById('output-img');
            img.src=url;img.style.display='block';
            document.getElementById('placeholder')?.remove();
            send('apply-image-fill',{data:url});
          });
          return;
      }

      if(effect==='liquid' && msg.shape){
        currentShape = msg.shape;
        const img=new Image();
        img.onload=()=>{
          canvas.width=img.width; canvas.height=img.height;
          gl.viewport(0,0,canvas.width,canvas.height);

          if(!tex) tex=gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D,tex);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // Flip the image to match WebGL's coordinate system
          gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);

          gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
          gl.uniform1i(uniforms.backgroundTexture, 0);

          updateUniformsAndRedraw();
        };
        img.src=msg.data;
      }
    };

    function redraw(){
      if(!tex || !currentShape)return;
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
      const croppedDataUrl = cropCanvasResult(canvas, OFFSET);
      send('apply-image-fill',{data:croppedDataUrl});
    }

    function cropCanvasResult(sourceCanvas, offset) {
        const tempCanvas = document.createElement('canvas');
        const w = sourceCanvas.width - offset * 2;
        const h = sourceCanvas.height - offset * 2;
        if (w <= 0 || h <= 0) return sourceCanvas.toDataURL('image/png');
        tempCanvas.width = w;
        tempCanvas.height = h;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(sourceCanvas, offset, offset, w, h, 0, 0, w, h);
        return tempCanvas.toDataURL('image/png');
    }

    function cropAndInvert(dataURL){
      return new Promise(res=>{
        const i=new Image();i.onload=()=>{
          const w=i.width-OFFSET*2,h=i.height-OFFSET*2,
                c=document.createElement('canvas');c.width=w;c.height=h,
                x=c.getContext('2d');
          x.drawImage(i,OFFSET,OFFSET,w,h,0,0,w,h);
          const id=x.getImageData(0,0,w,h),d=id.data;
          for(let p=0;p<d.length;p+=4){d[p]=255-d[p];d[p+1]=255-d[p+1];d[p+2]=255-d[p+2];}
          x.putImageData(id,0,0);res(c.toDataURL('image/png'));
        };i.src=dataURL;
      });
    }
  </script>
 </body>
 </html>