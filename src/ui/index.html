<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Liquid Glass</title>
  <style>
    /* A modern, clean, dark theme */
    :root {
      --bg-color: #1E1E1E;
      --bg-secondary-color: #2A2A2A;
      --text-color: #E0E0E0;
      --text-secondary-color: #9E9E9E;
      --primary-color: #0D99FF;
      --primary-color-hover: #3FB1FF;
      --border-color: #3A3A3A;
      --tab-active-color: #3A3A3A;
    }

    /* Custom Scrollbar Styles */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 3px;
      transition: background-color 0.2s ease;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary-color);
    }

    /* Firefox scrollbar */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--border-color) transparent;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      height: 100vh;
      overflow: hidden;
    }

    /* Tab System */
    .tab-container {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-secondary-color);
    }

    .tab-button {
      flex: 1;
      padding: 4px 16px;
      background: transparent;
      border: none;
      color: var(--text-secondary-color);
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .tab-button.active {
      color: var(--text-color);
      background: var(--tab-active-color);
      border-bottom: 2px solid var(--primary-color);
    }

    .tab-button:hover:not(.active) {
      color: var(--text-color);
      background: rgba(255, 255, 255, 0.05);
    }

    /* Main content area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 16px;
      overflow-y: auto;
    }

    #output-area {
      margin: 0 0 16px 0;
      padding: 0;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary-color);
      text-align: center;
      border-radius: 8px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      min-height: 150px;
      max-height: 200px;
      transition: all 0.3s ease;
    }
    
    #output-area.hidden {
      display: none;
    }

    #placeholder {
      color: var(--text-secondary-color);      
    }

    #lg-canvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      object-fit: contain;
    }

    /* Tab Content */
    .tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
    }

    .tab-content.active {
      display: block;
    }

    /* Controls */
    .controls-section {
      margin-bottom: 20px;
    }

    .section-title {
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 4px;
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.5px;
    }

    /* Draggable Input Styles */
    .draggable-input { 
      background-color: var(--bg-secondary-color);
      color: var(--text-color);
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 11px;
      width: 50px;
      max-width: 50px;
      min-width: 32px;
      text-align: center;
      font-variant-numeric: tabular-nums;
      border: 1px solid transparent;
      cursor: ew-resize;
      transition: all 0.2s ease;
      user-select: none;
      box-sizing: border-box;
    }

    .draggable-input:hover {
      border-color: var(--border-color);
      cursor: ew-resize;
    }

    .draggable-input:focus {
      outline: none;
      border-color: var(--primary-color);
      cursor: text;
      user-select: auto;
    }

    .draggable-input.dragging {
      cursor: ew-resize;
      border-color: var(--primary-color);
      user-select: none;
    }

    /* Updated 2-column control layout */
    .control-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 8px;
    }

    .control-cell {
      display: flex;
      justify-content: space-between;
      align-items: center;
      min-height: 24px;
    }

    .control-cell.empty {
      /* Empty cell for spacing */
    }

    .control-cell .control-label {
      font-size: 12px;
      color: var(--text-secondary-color);
      white-space: nowrap;
    }

    .control-cell .draggable-input,
    .control-cell .color-input {
      flex-shrink: 0;
    }

    /* Full width for blend mode */
    .control-full-width {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 12px;
    }

    .control-full-width .control-label {
      font-size: 12px;
      color: var(--text-secondary-color);
    }

    .control-full-width select {
      flex: 1;
      padding: 4px 6px;
      background: var(--bg-secondary-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
    }

    /* Minimal color picker */
    .color-input {
      width: 50px;
      height: 24px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: transparent;
      cursor: pointer;
      padding: 0;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    .color-input::-webkit-color-swatch-wrapper {
      padding: 0;
      border: none;
      border-radius: 3px;
    }

    .color-input::-webkit-color-swatch {
      border: none;
      border-radius: 3px;
    }

    .color-input::-moz-color-swatch {
      border: none;
      border-radius: 3px;
    }

    .color-input:hover {
      border-color: var(--text-secondary-color);
    }

    /* Main content area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 16px;
      overflow-y: auto;
    }

    #output-area {
      margin: 0 0 16px 0;
      padding: 0;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary-color);
      text-align: center;
      border-radius: 8px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      min-height: 150px;
      max-height: 200px;
      transition: all 0.3s ease;
    }
    
    #output-area.hidden {
      display: none;
    }

    #placeholder {
      color: var(--text-secondary-color);      
    }

    #lg-canvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
      object-fit: contain;
    }

    /* Tab Content */
    .tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
    }

    .tab-content.active {
      display: block;
    }

    /* Controls */
    .controls-section {
      margin-bottom: 20px;
    }

    .section-title {
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 4px;
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.5px;
    }

    /* Multi-column control layouts */
    .control-row-2 {
      display: grid;
      grid-template-columns: auto 1fr auto 1fr;
      grid-template-areas: "label1 value1 label2 value2";
      align-items: center;
      margin-bottom: 8px;
      color: var(--text-secondary-color);
      gap: 12px;
    }

    .control-row-3 {
      display: grid;
      grid-template-columns: auto auto 1fr auto 1fr;
      grid-template-areas: "label label1 value1 label2 value2";
      align-items: center;
      margin-bottom: 8px;
      color: var(--text-secondary-color);
      gap: 12px;
    }

    .control-row-4 {
      display: grid;
      grid-template-columns: auto 1fr auto 1fr auto 1fr;
      grid-template-areas: "label1 value1 label2 value2 label3 value3";
      align-items: center;
      margin-bottom: 8px;
      color: var(--text-secondary-color);
      gap: 12px;
    }

    .control-row-full {
      display: grid;
      grid-template-columns: auto 1fr;
      grid-template-areas: "label value";
      align-items: center;
      margin-bottom: 8px;
      color: var(--text-secondary-color);
      gap: 12px;
    }

    .control-label {
      font-size: 12px;
      color: var(--text-secondary-color);
      white-space: nowrap;
    }

    .control-row-2 > .control-label:nth-of-type(1) { grid-area: label1; }
    .control-row-2 > .control-label:nth-of-type(3) { grid-area: label2; }
    .control-row-3 > .control-label:nth-of-type(1) { grid-area: label; }
    .control-row-3 > .control-label:nth-of-type(2) { grid-area: label1; }
    .control-row-3 > .control-label:nth-of-type(4) { grid-area: label2; }
    .control-row-4 > .control-label:nth-of-type(1) { grid-area: label1; }
    .control-row-4 > .control-label:nth-of-type(3) { grid-area: label2; }
    .control-row-4 > .control-label:nth-of-type(5) { grid-area: label3; }
    .control-row-full > .control-label { grid-area: label; }

    .control-row-2 > .draggable-input:nth-of-type(2) { grid-area: value1; }
    .control-row-2 > .draggable-input:nth-of-type(4) { grid-area: value2; }
    .control-row-3 > .draggable-input:nth-of-type(3) { grid-area: value1; }
    .control-row-3 > .draggable-input:nth-of-type(5) { grid-area: value2; }
    .control-row-4 > .draggable-input:nth-of-type(2) { grid-area: value1; }
    .control-row-4 > .draggable-input:nth-of-type(4) { grid-area: value2; }
    .control-row-4 > .draggable-input:nth-of-type(6) { grid-area: value3; }
    .control-row-full > .draggable-input { grid-area: value; }

    .control-row-2 > .color-input:nth-of-type(2) { grid-area: value1; }
    .control-row-2 > .color-input:nth-of-type(4) { grid-area: value2; }
    .control-row-full > .color-input { grid-area: value; }

    .control-row-full > select { 
      grid-area: value;
      padding: 4px 6px;
      background: var(--bg-secondary-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
    }

    /* Sticky Footer */
    .sticky-footer {
      flex-shrink: 0;
      padding: 8px 16px;
      border-top: 1px solid var(--border-color);
      background: var(--bg-color);
    }

    .button-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .button {
      flex-grow: 1;
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 8px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: background-color 0.2s ease;
    }

    .button:hover {
      background-color: var(--primary-color-hover);
    }

    .button:disabled {
      background-color: var(--border-color);
      color: var(--text-secondary-color);
      cursor: not-allowed;
    }

    footer {
      text-align: center;
      color: var(--text-secondary-color);
      font-size: 11px;
    }

    footer a {
      color: var(--text-secondary-color);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: color 0.2s ease;
    }

    footer a:hover {
      color: var(--text-color);
    }

    footer svg {
      fill: currentColor;
    }

    .draggable-input.mixed-value,
    .color-input.mixed-value {
      font-style: italic;
      color: var(--text-secondary-color);
    }

    select.mixed-value {
      font-style: italic;
      color: var(--text-secondary-color);
    }

    .draggable-input.being-edited {
      color: var(--text-color);
      font-style: normal;
    }

    /* Custom dropdown styles */
    .custom-dropdown {
      position: relative;
      width: 100%;
    }

    .dropdown-selected {
      padding: 4px 6px;
      background: var(--bg-secondary-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }

    .dropdown-selected:hover {
      border-color: var(--text-secondary-color);
    }

    .dropdown-selected.open {
      border-color: var(--primary-color);
      border-top-left-radius: 0;
      border-top-right-radius: 0;
    }

    .dropdown-arrow {
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid var(--text-secondary-color);
      transition: transform 0.2s ease;
    }

    .dropdown-selected.open .dropdown-arrow {
      transform: rotate(180deg);
    }

    .dropdown-options {
      position: absolute;
      bottom: 100%;
      left: 0;
      right: 0;
      background: var(--bg-secondary-color);
      border: 1px solid var(--primary-color);
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.3);
    }

    .dropdown-options.open {
      display: block;
    }

    .dropdown-option {
      padding: 4px 6px;
      font-size: 11px;
      cursor: pointer;
      transition: background-color 0.1s ease;
    }

    .dropdown-option:hover {
      background: var(--border-color);
    }

    .dropdown-option.selected {
      background: var(--primary-color);
      color: white;
    }

    .dropdown-option.separator {
      border-bottom: 1px solid var(--border-color);
      cursor: default;
      padding: 2px 6px;
      font-size: 10px;
      color: var(--text-secondary-color);
      background: var(--bg-color);
    }

    .dropdown-option.separator:hover {
      background: var(--bg-color);
    }

    .dropdown-selected.mixed-value {
      font-style: italic;
      color: var(--text-secondary-color);
    }
  </style>
</head>
<body>
  <!-- Tab Navigation -->
  <div class="tab-container">
    <button class="tab-button active" data-tab="refraction">Refraction</button>
    <button class="tab-button" data-tab="effects">Effects</button>
  </div>

  <!-- Main Content Area -->
  <div class="main-content">
    <!-- Output Area - Only shown on Refraction tab -->
    <div id="output-area">
      <em id="placeholder">      
          Select or create a Liquid Glass element.
          <br><br>
          Plugin needs to be kept open to update the effect.      
      </em>
      <canvas id="lg-canvas" width="1" height="1" style="display:none"></canvas>
    </div>

    <!-- Refraction Tab -->
    <div class="tab-content active" id="refraction-tab">
      <div class="controls-section">
        <div class="section-title">Refraction</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Thickness</span>
            <input type="text" class="draggable-input" id="edge" value="20" data-min="1" data-max="50">
          </div>
          <div class="control-cell">
            <span class="control-label">Strength</span>
            <input type="text" class="draggable-input" id="strength" value="25" data-min="1" data-max="100">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Aberration</span>
            <input type="text" class="draggable-input" id="ca" value="5" data-min="0" data-max="30">
          </div>
          <div class="control-cell">
            <span class="control-label">Blur</span>
            <input type="text" class="draggable-input" id="frost" value="0" data-min="0" data-max="20">
          </div>
        </div>
      </div>
    </div>

    <!-- Effects Tab -->
    <div class="tab-content" id="effects-tab">
      <!-- Inner Shadow Section -->
      <div class="controls-section">
        <div class="section-title">Inner shadow</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">X offset</span>
            <input type="text" class="draggable-input" id="inner-shadow-x" value="10" data-min="0" data-max="50">
          </div>
          <div class="control-cell">
            <span class="control-label">Y offset</span>
            <input type="text" class="draggable-input" id="inner-shadow-y" value="10" data-min="0" data-max="50">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Blur</span>
            <input type="text" class="draggable-input" id="inner-shadow-blur" value="10" data-min="0" data-max="50">
          </div>
          <div class="control-cell">
            <span class="control-label">Spread</span>
            <input type="text" class="draggable-input" id="inner-shadow-spread" value="0" data-min="0" data-max="50">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Opacity</span>
            <input type="text" class="draggable-input" id="inner-shadow-opacity" value="40" data-min="0" data-max="100">
          </div>
          <div class="control-cell empty"></div>
        </div>
      </div>

      <!-- Edge Highlight Section -->
      <div class="controls-section">
        <div class="section-title">Edge highlight</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Angle</span>
            <input type="text" class="draggable-input" id="stroke-angle" value="0" data-min="0" data-max="360">
          </div>
          <div class="control-cell">
            <span class="control-label">Thickness</span>
            <input type="text" class="draggable-input" id="stroke-thickness" value="1" data-min="0" data-max="10">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Color</span>
            <input type="color" class="color-input" id="stroke-color" value="#ffffff">
          </div>
          <div class="control-cell">
            <span class="control-label">Opacity</span>
            <input type="text" class="draggable-input" id="stroke-opacity" value="100" data-min="0" data-max="100">
          </div>
        </div>
      </div>

      <!-- Reflection Section -->
      <div class="controls-section">
        <div class="section-title">Reflection</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Thickness</span>
            <input type="text" class="draggable-input" id="highlight-stroke-weight" value="12" data-min="0" data-max="50">
          </div>
          <div class="control-cell">
            <span class="control-label">Blur</span>
            <input type="text" class="draggable-input" id="highlight-blur" value="14" data-min="0" data-max="50">
          </div>
        </div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Color</span>
            <input type="color" class="color-input" id="reflection-color" value="#ffffff">
          </div>
          <div class="control-cell">
            <span class="control-label">Opacity</span>
            <input type="text" class="draggable-input" id="reflection-opacity" value="100" data-min="0" data-max="100">
          </div>
        </div>
      </div>

      <!-- Tint Section -->
      <div class="controls-section">
        <div class="section-title">Tint</div>
        
        <div class="control-grid">
          <div class="control-cell">
            <span class="control-label">Color</span>
            <input type="color" class="color-input" id="tint-color" value="#ffffff">
          </div>
          <div class="control-cell">
            <span class="control-label">Opacity</span>
            <input type="text" class="draggable-input" id="tint-opacity" value="20" data-min="0" data-max="100">
          </div>
        </div>
        
        <div class="control-full-width">
          <span class="control-label">Blend mode</span>
          <div class="custom-dropdown" id="tint-blend-mode-dropdown">
            <div class="dropdown-selected" id="blend-mode-selected">
              <span id="blend-mode-text">Normal</span>
              <div class="dropdown-arrow"></div>
            </div>
            <div class="dropdown-options" id="blend-mode-options">
              <div class="dropdown-option" data-value="PASS_THROUGH">Pass through</div>
              <div class="dropdown-option selected" data-value="NORMAL">Normal</div>
              <div class="dropdown-option separator">────────────</div>
              <div class="dropdown-option" data-value="DARKEN">Darken</div>
              <div class="dropdown-option" data-value="MULTIPLY">Multiply</div>
              <div class="dropdown-option" data-value="PLUS_DARKER">Linear burn</div>
              <div class="dropdown-option" data-value="COLOR_BURN">Color burn</div>
              <div class="dropdown-option separator">────────────</div>
              <div class="dropdown-option" data-value="LIGHTEN">Lighten</div>
              <div class="dropdown-option" data-value="SCREEN">Screen</div>
              <div class="dropdown-option" data-value="PLUS_LIGHTER">Linear dodge</div>
              <div class="dropdown-option" data-value="COLOR_DODGE">Color dodge</div>
              <div class="dropdown-option separator">────────────</div>
              <div class="dropdown-option" data-value="OVERLAY">Overlay</div>
              <div class="dropdown-option" data-value="SOFT_LIGHT">Soft light</div>
              <div class="dropdown-option" data-value="HARD_LIGHT">Hard light</div>
              <div class="dropdown-option separator">────────────</div>
              <div class="dropdown-option" data-value="DIFFERENCE">Difference</div>
              <div class="dropdown-option" data-value="EXCLUSION">Exclusion</div>
              <div class="dropdown-option separator">────────────</div>
              <div class="dropdown-option" data-value="HUE">Hue</div>
              <div class="dropdown-option" data-value="SATURATION">Saturation</div>
              <div class="dropdown-option" data-value="COLOR">Color</div>
              <div class="dropdown-option" data-value="LUMINOSITY">Luminosity</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Sticky Footer -->
  <div class="sticky-footer">
    <div class="button-row">
      <button class="button" id="create-btn">Create New</button>
      <button class="button" id="update-all-btn">Update all</button>
    </div>

    <footer>
      by Prabin Pebam
      <a href="https://github.com/prabinpebam/figma-liquid-glass" target="_blank">
        <svg width="12" height="12" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8C0 11.54 2.29 14.53 5.47 15.59C5.87 15.66 6.02 15.42 6.02 15.21C6.02 15.02 6.01 14.49 6.01 13.79C3.92 14.25 3.42 12.86 3.42 12.86C3.06 11.93 2.52 11.69 2.52 11.69C1.81 11.2 2.57 11.2 2.57 11.2C3.35 11.25 3.78 12.01 3.78 12.01C4.48 13.24 5.64 12.88 6.08 12.69C6.15 12.22 6.33 11.9 6.53 11.73C4.75 11.53 2.87 10.89 2.87 7.91C2.87 7.02 3.18 6.29 3.64 5.71C3.57 5.51 3.33 4.79 3.71 3.94C3.71 3.94 4.39 3.72 5.99 4.76C6.63 4.58 7.32 4.49 8 4.49C8.68 4.49 9.37 4.58 10.01 4.76C11.61 3.72 12.29 3.94 12.29 3.94C12.67 4.79 12.43 5.51 12.36 5.71C12.82 6.29 13.13 7.02 13.13 7.91C13.13 10.9 11.24 11.53 9.46 11.73C9.71 11.95 9.99 12.38 9.99 13.01C9.99 13.89 9.98 14.97 9.98 15.21C9.98 15.42 10.13 15.67 10.54 15.59C13.71 14.53 16 11.53 16 8C16 3.58 12.42 0 8 0Z"></path></svg>
        figma-liquid-glass
      </a>
    </footer>
  </div>

  <!-- JavaScript -->
  <script>
    console.log('Starting UI initialization...');

    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_texCoord;
      void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_position * 0.5 + 0.5;
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;
      varying vec2 v_texCoord;

      uniform vec2 u_resolution;
      uniform sampler2D u_backgroundTexture;
      uniform sampler2D u_sdfTexture;
      uniform vec2 u_rectangleSize;
      uniform float u_rectangleCornerRadius;
      uniform float u_edgeDistortionThickness;
      uniform float u_refractionStrength;
      uniform float u_chromaticAberrationAmount;
      uniform float u_frostiness;
      uniform int u_shapeType;
      uniform bool u_useSDFTexture;

      float sdRoundedBox( vec2 p, vec2 b, float r ) {
          vec2 q = abs(p) - b + r;
          return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;
      }

      float sdEllipse( vec2 p, vec2 r ) {
          float k0 = length(p/r);
          float k1 = length(p/(r*r));
          return k0*(k0-1.0)/k1;
      }

      vec4 renderBackground(vec2 coord) {
          vec2 uv = coord / u_resolution;
          return texture2D(u_backgroundTexture, uv);
      }

      vec4 renderLiquidGlass(vec2 currentPixelCoord, vec2 normDirToCenter, bool caActive, float distortion) {
          if (u_frostiness < 0.1) {
              if (caActive) {
                  float rDist = max(0.0, distortion - u_chromaticAberrationAmount * 0.5);
                  float bDist = distortion + u_chromaticAberrationAmount * 0.5;
                  vec2 rCoord = currentPixelCoord - normDirToCenter * rDist;
                  vec2 gCoord = currentPixelCoord - normDirToCenter * distortion;
                  vec2 bCoord = currentPixelCoord - normDirToCenter * bDist;
                  vec4 color;
                  color.r = renderBackground(rCoord).r;
                  color.g = renderBackground(gCoord).g;
                  color.b = renderBackground(bCoord).b;
                  color.a = renderBackground(gCoord).a;
                  return color;
              } else {
                  vec2 samplingCoord = currentPixelCoord - normDirToCenter * distortion;
                  return renderBackground(samplingCoord);
              }
          }

          vec4 totalColor = vec4(0.0);
          float sampleCount = 0.0;
          for (int x = -2; x <= 2; x++) {
              for (int y = -2; y <= 2; y++) {
                  vec2 frostOffset = vec2(float(x), float(y)) * u_frostiness * 0.5;
                  vec2 baseFrostedPixelCoord = currentPixelCoord + frostOffset;

                  if (caActive) {
                      float rDist = max(0.0, distortion - u_chromaticAberrationAmount * 0.5);
                      float bDist = distortion + u_chromaticAberrationAmount * 0.5;
                      vec2 rCoord = baseFrostedPixelCoord - normDirToCenter * rDist;
                      vec2 gCoord = baseFrostedPixelCoord - normDirToCenter * distortion;
                      vec2 bCoord = baseFrostedPixelCoord - normDirToCenter * bDist;
                      totalColor.r += renderBackground(rCoord).r;
                      totalColor.g += renderBackground(gCoord).g;
                      totalColor.b += renderBackground(bCoord).b;
                      totalColor.a += renderBackground(gCoord).a;
                  } else {
                      vec2 samplingCoord = baseFrostedPixelCoord - normDirToCenter * distortion;
                      totalColor += renderBackground(samplingCoord);
                  }
                  sampleCount += 1.0;
              }
          }
          return totalColor / sampleCount;
      }

      void main() {
          vec2 glassCenter = u_resolution * 0.5;
          vec2 currentPixelCoord = v_texCoord * u_resolution;
          vec2 relativeToCenter = currentPixelCoord - glassCenter;

          float sdf;
          
          if (u_useSDFTexture) {
              vec2 uv = v_texCoord;
              float dist = texture2D(u_sdfTexture, uv).r;
              sdf = (dist - 0.5) * min(u_resolution.x, u_resolution.y);
          } else if (u_shapeType == 1) {
              sdf = sdEllipse(relativeToCenter, u_rectangleSize * 0.5);
          } else {
              float cornerRadius = min(u_rectangleCornerRadius, min(u_rectangleSize.x, u_rectangleSize.y) * 0.5);
              sdf = sdRoundedBox(relativeToCenter, u_rectangleSize * 0.5, cornerRadius);
          }

          if (sdf > 0.0) {
              gl_FragColor = renderBackground(currentPixelCoord);
              return;
          }

          bool isInEdge = sdf > -u_edgeDistortionThickness;
          float edgeAmount = isInEdge ? (sdf + u_edgeDistortionThickness) / u_edgeDistortionThickness : 0.0;
          float distortion = isInEdge ? u_refractionStrength * pow(clamp(edgeAmount, 0.0, 1.0), 2.0) : 0.0;
          bool caActive = isInEdge && u_chromaticAberrationAmount > 0.001;
          vec2 normDir = length(relativeToCenter) > 0.001 ? normalize(relativeToCenter) : vec2(0.707, 0.707);

          gl_FragColor = renderLiquidGlass(currentPixelCoord, normDir, caActive, distortion);
      }
    `;

    const OFFSET = 20;
    const send = (t, p) => parent.postMessage({ pluginMessage: { type: t, ...p } }, '*');

    // WebGL context and variables
    let canvas, gl, program;
    let uniforms = {};
    let tex = null, sdfTex = null;
    let currentShape = null, currentShapeType = 'rectangle';
    let createBtn, updateAllBtn, placeholder;

    // UI State
    let isMultipleSelection = false;
    let hasMixedValues = {};
    let lgElementCount = 0;
    let currentBlendModeOriginal = 'NORMAL';
    let isBlendModeDropdownOpen = false;

    // Tab system
    function initializeTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');
      const outputArea = document.getElementById('output-area');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');
          
          // Update button states
          tabButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          
          // Update content states
          tabContents.forEach(content => content.classList.remove('active'));
          document.getElementById(targetTab + '-tab').classList.add('active');
          
          // Show/hide output area based on active tab
          if (targetTab === 'refraction') {
            outputArea.classList.remove('hidden');
          } else {
            outputArea.classList.add('hidden');
          }
        });
      });
    }

    function initGL() {
      const vs = compile(gl, vertexShaderSource, gl.VERTEX_SHADER);
      const fs = compile(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
      program = link(gl, vs, fs);
      gl.useProgram(program);

      uniforms.edge = gl.getUniformLocation(program, 'u_edgeDistortionThickness');
      uniforms.strength = gl.getUniformLocation(program, 'u_refractionStrength');
      uniforms.ca = gl.getUniformLocation(program, 'u_chromaticAberrationAmount');
      uniforms.frost = gl.getUniformLocation(program, 'u_frostiness');
      uniforms.resolution = gl.getUniformLocation(program, 'u_resolution');
      uniforms.rectSize = gl.getUniformLocation(program, 'u_rectangleSize');
      uniforms.cornerRadius = gl.getUniformLocation(program, 'u_rectangleCornerRadius');
      uniforms.backgroundTexture = gl.getUniformLocation(program, 'u_backgroundTexture');
      uniforms.sdfTexture = gl.getUniformLocation(program, 'u_sdfTexture');
      uniforms.shapeType = gl.getUniformLocation(program, 'u_shapeType');
      uniforms.useSDFTexture = gl.getUniformLocation(program, 'u_useSDFTexture');

      const pos = gl.getAttribLocation(program, 'a_position');
      const quad = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(pos);
      gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);
    }

    function compile(gl, src, type) {
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(s) || 'Shader compilation failed');
      }
      return s;
    }

    function link(gl, vs, fs) {
      const p = gl.createProgram();
      gl.attachShader(p, vs);
      gl.attachShader(p, fs);
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(p) || 'Program linking failed');
      }
      return p;
    }

    function updateValueDisplay(slider) {
      const output = document.getElementById(slider.id + '-value');
      if (output) output.textContent = slider.value;
    }

    function getAllParams() {
      return {
        // Refraction params
        edge: +document.getElementById('edge').value,
        strength: +document.getElementById('strength').value,
        ca: +document.getElementById('ca').value,
        frost: +document.getElementById('frost').value,
        
        // Effects params
        innerShadowX: +document.getElementById('inner-shadow-x').value,
        innerShadowY: +document.getElementById('inner-shadow-y').value,
        innerShadowBlur: +document.getElementById('inner-shadow-blur').value,
        innerShadowSpread: +document.getElementById('inner-shadow-spread').value,
        innerShadowOpacity: +document.getElementById('inner-shadow-opacity').value,
        strokeAngle: +document.getElementById('stroke-angle').value,
        strokeColor: document.getElementById('stroke-color').value,
        strokeThickness: +document.getElementById('stroke-thickness').value,
        strokeOpacity: +document.getElementById('stroke-opacity').value,
        highlightStrokeWeight: +document.getElementById('highlight-stroke-weight').value,
        highlightBlur: +document.getElementById('highlight-blur').value,
        reflectionColor: document.getElementById('reflection-color').value,
        reflectionOpacity: +document.getElementById('reflection-opacity').value,
        tintColor: document.getElementById('tint-color').value,
        tintOpacity: +document.getElementById('tint-opacity').value,
        tintBlendMode: window.getBlendModeValue ? window.getBlendModeValue() : 'NORMAL',
      };
    }

    function updateUniformsAndRedraw(params) {
      if (!currentShape) return;
      gl.useProgram(program);
      gl.uniform1f(uniforms.edge, params.edge);
      gl.uniform1f(uniforms.strength, params.strength);
      gl.uniform1f(uniforms.ca, params.ca);
      gl.uniform1f(uniforms.frost, params.frost);
      gl.uniform2f(uniforms.rectSize, currentShape.width, currentShape.height);
      gl.uniform1f(uniforms.cornerRadius, currentShape.cornerRadius);
      
      const shapeTypeValue = currentShapeType === 'ellipse' ? 1 : 0;
      gl.uniform1i(uniforms.shapeType, shapeTypeValue);
      gl.uniform1i(uniforms.useSDFTexture, currentShapeType === 'complex' ? 1 : 0);
      
      redraw();
    }

    function redraw() {
      if (!tex || !currentShape) return;
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function cropCanvasResult(sourceCanvas, offset) {
      const tempCanvas = document.createElement('canvas');
      const w = sourceCanvas.width - offset * 2;
      const h = sourceCanvas.height - offset * 2;
      if (w <= 0 || h <= 0) return sourceCanvas.toDataURL('image/png');
      tempCanvas.width = w;
      tempCanvas.height = h;
      const ctx = tempCanvas.getContext('2d');
      ctx.drawImage(sourceCanvas, offset, offset, w, h, 0, 0, w, h);
      return tempCanvas.toDataURL('image/png');
    }

    function updateInputDisplay(input, value, isMixed) {
      if (isMixed) {
        input.value = '--';
        input.classList.add('mixed-value');
      } else {
        input.value = value.toString();
        input.classList.remove('mixed-value');
      }
    }

    function updateColorInputDisplay(input, value, isMixed) {
      if (isMixed) {
        input.style.background = 'linear-gradient(45deg, #666 25%, transparent 25%, transparent 75%, #666 75%, #666), linear-gradient(45deg, #666 25%, transparent 25%, transparent 75%, #666 75%, #666)';
        input.style.backgroundSize = '8px 8px';
        input.style.backgroundPosition = '0 0, 4px 4px';
        input.value = '#000000'; // Fallback value
      } else {
        input.style.background = '';
        input.style.backgroundSize = '';
        input.style.backgroundPosition = '';
        input.value = value;
      }
    }

    function updateSelectDisplay(select, value, isMixed) {
      // This function is no longer used for blend mode since we have a custom dropdown
      // Keep it for compatibility but make it handle null elements
      if (!select) return;
      
      if (isMixed) {
        // Add a mixed value option if it doesn't exist
        let mixedOption = select.querySelector('option[value="--mixed--"]');
        if (!mixedOption) {
          mixedOption = document.createElement('option');
          mixedOption.value = '--mixed--';
          mixedOption.textContent = '--';
          select.insertBefore(mixedOption, select.firstChild);
        }
        select.value = '--mixed--';
        select.classList.add('mixed-value');
      } else {
        // Remove mixed option if it exists
        const mixedOption = select.querySelector('option[value="--mixed--"]');
        if (mixedOption) {
          mixedOption.remove();
        }
        select.value = value;
        select.classList.remove('mixed-value');
      }
    }

    // Message handling
    window.onmessage = async (e) => {
      const msg = e.data.pluginMessage;
      if (!msg) return;
      
      console.log('UI received message:', msg.type, msg);

      if (msg.type === 'plugin-ready') {
        console.log('Plugin ready, ensuring UI is initialized');
        if (!createBtn) {
          initializeUI();
        }
        return;
      }

      if (msg.type === 'update-ui-controls') {
        isMultipleSelection = msg.isMultipleSelection || false;
        hasMixedValues = msg.hasMixedValues || {};
        lgElementCount = msg.lgElementCount || 0;
        
        createBtn.disabled = msg.isSelected;
        createBtn.textContent = 'Create New';
        updateAllBtn.textContent = isMultipleSelection ? `Update selection (${lgElementCount})` : 'Update selection';
        
        // Update refraction params with mixed value detection
        updateInputDisplay(document.getElementById('edge'), msg.params.edge || 20, hasMixedValues.edge);
        updateInputDisplay(document.getElementById('strength'), msg.params.strength || 25, hasMixedValues.strength);
        updateInputDisplay(document.getElementById('ca'), msg.params.ca || 5, hasMixedValues.ca);
        updateInputDisplay(document.getElementById('frost'), msg.params.frost || 0, hasMixedValues.frost);
        
        // Update effects params with mixed value detection
        if (msg.effectsParams) {
          const ep = msg.effectsParams;
          updateInputDisplay(document.getElementById('inner-shadow-x'), ep.innerShadowX || 10, hasMixedValues.innerShadowX);
          updateInputDisplay(document.getElementById('inner-shadow-y'), ep.innerShadowY || 10, hasMixedValues.innerShadowY);
          updateInputDisplay(document.getElementById('inner-shadow-blur'), ep.innerShadowBlur || 10, hasMixedValues.innerShadowBlur);
          updateInputDisplay(document.getElementById('inner-shadow-spread'), ep.innerShadowSpread || 0, hasMixedValues.innerShadowSpread);
          updateInputDisplay(document.getElementById('inner-shadow-opacity'), ep.innerShadowOpacity || 40, hasMixedValues.innerShadowOpacity);
          updateInputDisplay(document.getElementById('stroke-angle'), ep.strokeAngle || 0, hasMixedValues.strokeAngle);
          updateColorInputDisplay(document.getElementById('stroke-color'), ep.strokeColor || '#ffffff', hasMixedValues.strokeColor);
          updateInputDisplay(document.getElementById('stroke-thickness'), ep.strokeThickness || 1, hasMixedValues.strokeThickness);
          updateInputDisplay(document.getElementById('stroke-opacity'), ep.strokeOpacity || 100, hasMixedValues.strokeOpacity);
          updateInputDisplay(document.getElementById('highlight-stroke-weight'), ep.highlightStrokeWeight || 12, hasMixedValues.highlightStrokeWeight);
          updateInputDisplay(document.getElementById('highlight-blur'), ep.highlightBlur || 14, hasMixedValues.highlightBlur);
          updateColorInputDisplay(document.getElementById('reflection-color'), ep.reflectionColor || '#ffffff', hasMixedValues.reflectionColor);
          updateInputDisplay(document.getElementById('reflection-opacity'), ep.reflectionOpacity || 100, hasMixedValues.reflectionOpacity);
          updateColorInputDisplay(document.getElementById('tint-color'), ep.tintColor || '#ffffff', hasMixedValues.tintColor);
          updateInputDisplay(document.getElementById('tint-opacity'), ep.tintOpacity || 20, hasMixedValues.tintOpacity);
          
          // Update custom blend mode dropdown instead of using updateSelectDisplay
          if (window.updateBlendModeDisplay) {
            window.updateBlendModeDisplay(ep.tintBlendMode || 'NORMAL', hasMixedValues.tintBlendMode);
          }
        }
        
        if (msg.isSelected && !isMultipleSelection) {
          send('update-lg-element', { params: getAllParams() });
        }
        return;
      }

      if (msg.type === 'selection-changed') {
        isMultipleSelection = msg.isMultipleSelection || false;
        
        if (msg.canApplyEffect) {
          createBtn.textContent = 'Apply Effect';
          createBtn.disabled = false;
          updateAllBtn.textContent = 'Update all';
        } else if (msg.isLgElement) {
          createBtn.textContent = 'Create New';
          createBtn.disabled = true;
          if (isMultipleSelection) {
            updateAllBtn.textContent = `Update selection (${msg.lgElementCount || 0})`;
          } else {
            updateAllBtn.textContent = 'Update all';
          }
        } else {
          createBtn.textContent = 'Create New';
          createBtn.disabled = false;
          updateAllBtn.textContent = 'Update all';
        }
        return;
      }

      if (msg.type === 'selection-cleared') {
        isMultipleSelection = false;
        createBtn.disabled = false;
        createBtn.textContent = 'Create New';
        updateAllBtn.textContent = 'Update all';
        canvas.style.display = 'none';
        
        // Remove multiple values indicators
        document.querySelectorAll('.multiple-values').forEach(span => span.remove());
        
        if (!document.getElementById('placeholder')) {
          const newPlaceholder = document.createElement('em');
          newPlaceholder.id = 'placeholder';
          newPlaceholder.innerHTML = `      
            Select or create a Liquid Glass element.
            <br><br>
            Plugin needs to be kept open to update the effect.      
          `;
          document.getElementById('output-area').prepend(newPlaceholder);
        }
        return;
      }

      if (msg.type !== 'image-captured' || msg.error) return;

      if (msg.shape) {
        document.getElementById('placeholder')?.remove();
        currentShape = msg.shape;
        currentShapeType = msg.shapeType === 'complex' ? 'rectangle' : msg.shapeType;
        
        const img = new Image();
        img.onload = async () => {
          canvas.width = img.width;
          canvas.height = img.height;
          canvas.style.display = 'block';
          gl.viewport(0, 0, canvas.width, canvas.height);

          if (!tex) tex = gl.createTexture();
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, tex);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

          gl.uniform2f(uniforms.resolution, canvas.width, canvas.height);
          gl.uniform1i(uniforms.backgroundTexture, 0);

          updateUniformsAndRedraw(msg.params);
          
          const croppedDataUrl = cropCanvasResult(canvas, OFFSET);
          send('apply-image-fill', { data: croppedDataUrl, nodeId: msg.nodeId });
        };
        img.src = msg.data;
      }
    };

    function getElementIdForParam(paramName) {
      const paramMap = {
        'edge': 'edge',
        'strength': 'strength', 
        'ca': 'ca',
        'frost': 'frost',
        'innerShadowX': 'inner-shadow-x',
        'innerShadowY': 'inner-shadow-y',
        'innerShadowBlur': 'inner-shadow-blur',
        'innerShadowSpread': 'inner-shadow-spread',
        'innerShadowOpacity': 'inner-shadow-opacity',
        'strokeAngle': 'stroke-angle',
        'strokeColor': 'stroke-color',
        'strokeThickness': 'stroke-thickness',
        'strokeOpacity': 'stroke-opacity',
        'highlightStrokeWeight': 'highlight-stroke-weight',
        'highlightBlur': 'highlight-blur',
        'reflectionColor': 'reflection-color',
        'reflectionOpacity': 'reflection-opacity',
        'tintColor': 'tint-color',
        'tintOpacity': 'tint-opacity',
        'tintBlendMode': 'tint-blend-mode'
      };
      return paramMap[paramName] || paramName;
    }

    function handleControlChange(parameterName = null) {
      // Skip if input shows mixed values (unless user is actively changing it)
      const element = parameterName ? document.getElementById(getElementIdForParam(parameterName)) : null;
      if (element && element.value === '--' && !element.classList.contains('being-edited')) {
        return;
      }

      // Determine if we're updating refraction or effects parameters
      const isRefractionParam = ['edge', 'strength', 'ca', 'frost'].includes(parameterName);
      const isEffectsParam = parameterName && !isRefractionParam;
      
      // For single LG element selection - update with optimization
      if (createBtn.disabled && !isMultipleSelection) {
        const params = getAllParams();
        
        // Skip image capture for effects-only updates
        if (isEffectsParam) {
          send('update-lg-element-effects-only', { params, parameterName });
        } else {
          send('update-lg-element', { params });
        }
        return;
      }
      
      // For multiple selection - update all selected LG elements
      if (isMultipleSelection && parameterName) {
        const params = getAllParams();
        
        if (isEffectsParam) {
          // Send real-time update for effects parameters only
          send('update-effects-realtime', { 
            parameterName, 
            parameterValue: params[parameterName]
          });
        } else if (isRefractionParam) {
          // For refraction parameters, send full update
          send('update-selection-lg-elements', { params });
        }
      }
    }

    // Draggable input functionality
    function setupDraggableInputs() {
      const draggableInputs = document.querySelectorAll('.draggable-input');
      
      draggableInputs.forEach(input => {
        let isDragging = false;
        let startX = 0;
        let startValue = 0;
        let dragSensitivity = 1;
        
        const min = parseFloat(input.dataset.min) || 0;
        const max = parseFloat(input.dataset.max) || 100;
        
        // Get parameter name from input ID
        const parameterName = getParamNameFromElementId(input.id);
        
        // Calculate sensitivity based on 40% of screen width for full range
        const range = max - min;
        const targetPixelsForFullRange = window.screen.width * 0.4;
        dragSensitivity = range / targetPixelsForFullRange;

        input.addEventListener('mousedown', (e) => {
          if (e.detail === 1) { // Single click
            setTimeout(() => {
              if (!isDragging) {
                // Focus for editing
                input.focus();
                input.select();
                input.classList.add('being-edited');
                
                // Clear mixed value display when editing
                if (input.value === '--') {
                  input.value = '';
                  input.classList.remove('mixed-value');
                }
              }
            }, 200);
          }
          
          isDragging = false;
          
          // Handle mixed values - use the minimum value as starting point
          if (input.value === '--') {
            startValue = min;
            input.value = min.toString();
            input.classList.remove('mixed-value');
          } else {
            startValue = parseFloat(input.value) || 0;
          }
          
          startX = e.clientX;
          
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
          e.preventDefault();
        });

        function onMouseMove(e) {
          const deltaX = e.clientX - startX;
          
          if (Math.abs(deltaX) > 5 && !isDragging) {
            isDragging = true;
            input.classList.add('dragging');
            input.classList.remove('mixed-value');
            input.blur(); // Remove focus to prevent text editing
          }
          
          if (isDragging) {
            const newValue = Math.min(max, Math.max(min, startValue + (deltaX * dragSensitivity)));
            const roundedValue = Math.round(newValue);
            input.value = roundedValue.toString();
            handleControlChange(parameterName);
          }
        }

        function onMouseUp() {
          if (isDragging) {
            input.classList.remove('dragging');
          }
          
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          
          setTimeout(() => {
            isDragging = false;
          }, 100);
        }

        // Handle direct text input
        input.addEventListener('input', () => {
          if (!isDragging) {
            input.classList.remove('mixed-value');
            let value = parseFloat(input.value);
            if (isNaN(value)) return;
            
            value = Math.min(max, Math.max(min, value));
            input.value = Math.round(value).toString();
            handleControlChange(parameterName);
          }
        });

        // Handle Enter key and blur
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            input.blur();
          }
        });

        input.addEventListener('blur', () => {
          input.classList.remove('being-edited');
          
          // Handle mixed value case
          if (input.value === '' || input.value === '--') {
            input.value = min.toString();
          }
          
          let value = parseFloat(input.value);
          if (isNaN(value)) {
            input.value = min.toString();
            value = min;
          }
          
          value = Math.min(max, Math.max(min, value));
          input.value = Math.round(value).toString();
          handleControlChange(parameterName);
        });
      });
    }

    function getParamNameFromElementId(elementId) {
      const idMap = {
        'edge': 'edge',
        'strength': 'strength', 
        'ca': 'ca',
        'frost': 'frost',
        'inner-shadow-x': 'innerShadowX',
        'inner-shadow-y': 'innerShadowY',
        'inner-shadow-blur': 'innerShadowBlur',
        'inner-shadow-spread': 'innerShadowSpread',
        'inner-shadow-opacity': 'innerShadowOpacity',
        'stroke-angle': 'strokeAngle',
        'stroke-thickness': 'strokeThickness',
        'stroke-opacity': 'strokeOpacity',
        'highlight-stroke-weight': 'highlightStrokeWeight',
        'highlight-blur': 'highlightBlur',
        'reflection-opacity': 'reflectionOpacity',
        'tint-opacity': 'tintOpacity'
      };
      return idMap[elementId] || elementId;
    }

    function setupBlendModeDropdown() {
      const dropdown = document.getElementById('tint-blend-mode-dropdown');
      const selected = document.getElementById('blend-mode-selected');
      const options = document.getElementById('blend-mode-options');
      const selectedText = document.getElementById('blend-mode-text');
      
      let isOpen = false;
      let originalValue = 'NORMAL';
      let currentValue = 'NORMAL';

      // Get current blend mode value
      function getCurrentBlendMode() {
        const selectedOption = options.querySelector('.dropdown-option.selected');
        return selectedOption ? selectedOption.dataset.value : 'NORMAL';
      }

      // Set blend mode value and update UI
      function setBlendMode(value, isMixed = false) {
        // Remove previous selection
        options.querySelectorAll('.dropdown-option').forEach(opt => {
          opt.classList.remove('selected');
        });

        if (isMixed) {
          selectedText.textContent = '--';
          selected.classList.add('mixed-value');
        } else {
          // Find and select the option
          const option = options.querySelector(`[data-value="${value}"]`);
          if (option) {
            option.classList.add('selected');
            selectedText.textContent = option.textContent;
          }
          selected.classList.remove('mixed-value');
        }
        currentValue = value;
      }

      // Open dropdown
      function openDropdown() {
        if (isOpen) return;
        isOpen = true;
        originalValue = currentValue;
        selected.classList.add('open');
        options.classList.add('open');
        console.log('Blend mode dropdown opened, original value:', originalValue);
      }

      // Close dropdown
      function closeDropdown(commit = false) {
        if (!isOpen) return;
        isOpen = false;
        selected.classList.remove('open');
        options.classList.remove('open');

        if (!commit) {
          // Revert to original value
          console.log('Reverting blend mode to:', originalValue);
          setBlendMode(originalValue);
          send('revert-blend-mode', { originalBlendMode: originalValue });
        }
      }

      // Handle click on selected area
      selected.addEventListener('click', (e) => {
        e.stopPropagation();
        if (isOpen) {
          closeDropdown(false);
        } else {
          openDropdown();
        }
      });

      // Handle option hover
      options.addEventListener('mouseover', (e) => {
        if (!isOpen) return;
        
        const option = e.target.closest('.dropdown-option');
        if (option && !option.classList.contains('separator')) {
          const hoveredValue = option.dataset.value;
          if (hoveredValue) {
            console.log('Previewing blend mode:', hoveredValue);
            send('preview-blend-mode', { blendMode: hoveredValue });
          }
        }
      });

      // Handle option click
      options.addEventListener('click', (e) => {
        if (!isOpen) return;
        
        const option = e.target.closest('.dropdown-option');
        if (option && !option.classList.contains('separator')) {
          const selectedValue = option.dataset.value;
          if (selectedValue) {
            console.log('Committing blend mode:', selectedValue);
            setBlendMode(selectedValue);
            handleControlChange('tintBlendMode');
            closeDropdown(true);
          }
        }
      });

      // Handle click outside
      document.addEventListener('click', (e) => {
        if (isOpen && !dropdown.contains(e.target)) {
          console.log('Clicked outside dropdown, reverting to:', originalValue);
          closeDropdown(false);
        }
      });

      // Handle escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isOpen) {
          console.log('Escape pressed, reverting to:', originalValue);
          closeDropdown(false);
        }
      });

      // Expose function to update from external code
      window.updateBlendModeDisplay = function(value, isMixed) {
        setBlendMode(value, isMixed);
      };

      // Return current value getter for getAllParams
      window.getBlendModeValue = function() {
        return currentValue;
      };
    }

    function initializeUI() {
      console.log('Initializing UI...');
      
      canvas = document.getElementById('lg-canvas');
      if (!canvas) {
        console.error('Canvas element not found');
        return;
      }
      
      gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
      if (!gl) {
        console.error('WebGL not supported');
        return;
      }
      
      createBtn = document.getElementById('create-btn');
      updateAllBtn = document.getElementById('update-all-btn');
      placeholder = document.getElementById('placeholder');
      
      if (!createBtn || !updateAllBtn) {
        console.error('Button elements not found');
        return;
      }
      
      console.log('Elements found, initializing WebGL...');
      
      try {
        initGL();
        console.log('WebGL initialized successfully');
      } catch (e) {
        console.error('WebGL initialization failed:', e);
        return;
      }

      // Initialize tabs
      initializeTabs();

      // Set up draggable inputs
      setupDraggableInputs();

      // Set up blend mode dropdown with preview functionality
      setupBlendModeDropdown();

      // Set up event listeners
      createBtn.onclick = () => {
        console.log('Create button clicked');
        const params = getAllParams();
        
        console.log('Button clicked:', createBtn.textContent, params);
        
        if (createBtn.textContent === 'Apply Effect') {
          console.log('Sending apply-effect-to-selection message');
          send('apply-effect-to-selection', { params });
        } else {
          console.log('Sending create-lg-element message');
          send('create-lg-element', { params });
        }
      };

      updateAllBtn.onclick = () => {
        console.log('Update button clicked:', updateAllBtn.textContent);
        if (updateAllBtn.textContent.startsWith('Update selection')) {
          // Multiple LG elements are selected
          const params = getAllParams();
          send('update-selection-lg-elements', { params });
        } else {
          // "Update all" - update all LG elements on the page
          send('update-all-lg-elements', {});
        }
      };

      // Set up color pickers with parameter names
      const colorPickers = document.querySelectorAll('input[type="color"]');
      colorPickers.forEach((picker) => {
        const parameterName = getParamNameFromElementId(picker.id);
        picker.addEventListener('input', () => handleControlChange(parameterName));
      });

      console.log('UI initialized successfully');
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeUI);
    } else {
      initializeUI();
    }

    // Fallback initialization
    setTimeout(() => {
      if (!createBtn) {
        console.log('Fallback initialization attempt');
        initializeUI();
      }
    }, 500);
  </script>
</body>
</html>